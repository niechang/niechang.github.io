{"text":"###38. 检查参数的有效性\n- 公有的方法在执行之前先对参数进行检查\n- 非公有的方法通常应该使用断言(assertion)来检查它们的参数\n\n###39. 必要的时候进行保护性拷贝\n保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。\n对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝\n```\npublic final class Period {\n    private final Date start;\n    private final Date  end;\n    public Period (Date start, Date end){\n          this.start = new Date(start.getTime()); //由于Date类是可变的，需要进行保护性拷贝\n          this.end = new Date(end.getTime());\n          if (this.start.compareTo(this.end) > 0) {\n              throw new IllegalArgumentException(start + \" after\" + end);\n         }\n     }\n    public Date start() {\n          return new Date(start.getTime());\n     }\n}\n```\n\n###40. 谨慎设计方法签名\n- 谨慎选择方法的名称\n- 不要过于追求提供便利的方法\n- 避免过长的参数列表，可以通过分解多个方法、创建辅助类、Builder模式来缩短参数列表\n- 对于参数类型优先使用接口而不是类\n- 对于boolean类型，优先使用两个元素的枚举\n\n###41. 慎用重载\n- 重载方法(overload method)是在编译时做出决定的，其选择是静态的，而对于被覆盖的方法(overridden method)的选择则是动态的\n- 安全而保守的策略是永远不要到处两个具有相同参数数目的重载方法，如ObjectOutputStream包含`writeInt`、`writeFloat`等方法，而不是使用重载\n- JDK中反面例子：List中`remove(int)`和`remove(E)`、String类中`valueOf(char[])`和`valueOf(Object)`\n\n###42. 慎用可变参数\n- 可变参数方法接收0个或多个指定类型的参数，可变参数每次调用的时候都会导致进行一次数组分配和初始化\n- 不必改造具有final数组参数的每个方法，只当确实是在数量不定的值上执行调用时使用可变参数\n\n###43. 返回零长度的数组或者集合而不是null\n\n###44. 为所有导出的API元素编写文档注释\n- 必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释\n- 方法的文档注释应该简洁的描述出它和客户端之间的约定\n- 为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数\n- 为枚举类型编写文档时，要确保在文档中说明常量以及类型，还有任何公有方法\n- 为注解类型编写文档时，要确保在文档中说明所有成员以及类型本身\n"}