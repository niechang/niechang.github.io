{"text":"###桥接模式\n**意图**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n\n**动机**：当一个抽象可能有多个实现时，通常用继承来协调它们。抽象类定义对该抽象的接口，而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。\n\n**适用性**：\n\n- 你不希望在抽象和它的实现部分之间有一个固定的绑定关系\n- 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充\n- 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。\n\n**结构**\n![Alt text](http://img.itc.cn/photo/j3SRXnE7MhO)\n\n**参与者**：\n\n- Abstraction：定义抽象类的接口，维护一个指向Implementor类型对象的指针\n- RefinedAbstraction：扩充由Abstraction定义的接口\n- Implementor：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作\n- ConcreteImplementor：实现Implementor接口并定义它的具体实现\n\n**协作**：Abstraction将client的请求转发给它的Implementor对象\n\n**效果**：\n\n- 分离接口及其实现部分。一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。\n- 提高可扩充性你可以独立地对Abstraction和Implementor层次结构进行扩充\n- 实现细节对客户透明\n\n**变化**：\n\n- Implementor可以省略\n- RefinedAbstraction可以省略\n- 共享Implementors，Abstraction中可以有多个Implementor\n\n**JDK中实例**\nThe interfaces in the `java.awt.peer` package define the native GUI capabilities that are required by the heavy weight AWT components of the java.awt package.\n![Alt text](http://img.itc.cn/photo/j3CtfmDU6x8)\n\n###结构型模式讨论\n**Adapter与Bridge**\n\n- Adapter与Bridge模式具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。\n- Adapter模式主要是为了解决两个已有接口之间不匹配的问题。\n- Bridge模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。Bridge模式也会在系统演化时适应新的实现。\n- 当你发现两个不兼容的类必须同时工作时，就有必要使用Adapter模式，其目的一般是为了避免代码重复\n- Bridge的使用者必须事先知道：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的\n- Adapter模式在类已经设计好后实施；Bridge模式在设计类之前实施。\n- Facade并不能看成另外一组对象的适配器，这是由于Facade定义一个新的接口，而Adapter复用一个原有的接口\n\n**Composite、Decorator与Proxy**\n\n- Composite、Decorator模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。\n- Decorator旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。\n- Composite则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰，而在于表示。\n- Decorator和Proxy都描述了怎样为对象提供一定程度上的间接引用，proxy 和decorator对象的实现部分都保留了指向另一个对象的指针，它们向这个对象发送请求。\n- Proxy 模式构成一个对象并为用户提供一致的接口。但与Decorator模式不同的是， Proxy模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者。\n- 在Proxy模式中，实体定义了关键功能，而Proxy提供（或拒绝）对它的访问。Decorator模式中，组件仅提供了部分功能，而一个或多Decorator负责完成其他功能。Decorator模式适用于编译时不能（至少不方便）确定对象的全部功能的情况，Proxy模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达。\n"}