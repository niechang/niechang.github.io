{"text":"**意图**：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n**动机**：面向对象设计鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下 ,每一个对象都知道其他所有对象。\n\n**适用性**\n\n- 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。\n- 一个对象引用其他很多对象并且直接与这些对象通信 ,导致难以复用该对象。\n- 想定制一个分布在多个类中的行为，而又不想生成太多的子类\n\n**结构**\n![mediator](http://img.itc.cn/photo/j37iiIaECr1)\n\n**成员**\n\n- Mediator：中介者定义一个接口用于与各同事（Colleague）对象通信\n- ConcreteMediator：具体中介者通过协调各同事对象实现协作行为；了解并维护它的各个同事\n- Colleague：每一个同事类都知道它的中介者对象；每一个同事对象在需与其他的同事通信的时候，与它的中介者通信\n\n**协作**：同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。\n\n**效果**\n\n- 减少了子类生成Mediator将原本分布于多个对象间的行为集中在一起\n- 它将各Colleague解耦Mediator有利于各Colleague间的松耦合\n- 它对对象如何协作进行了抽象 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来\n- 它使控制集中化，中介者模式将交互的复杂性变为中介者的复杂性\n- 降低了Colleague之间的复杂度使之易于重用，但是增加Mediator自身的复杂性导致Mediator很难重用\n\n\n**实现**\n\n- 忽略抽象的Mediator类。当各Colleague仅与一个Mediator一起工作时 , 没有必要定义一个抽象的Mediator类\n- Colleague—Mediator通信 当一个感兴趣的事件发生时 , Colleague必须与其Mediator通信。\n     - 一种实现方法是使用 Observer模式，将Mediator实现为一个Observer，各Colleague作为Subject，一旦其状态改变就发送通知给Mediator。Mediator作出的响应是将状态改变的结果传播给其他的Colleague。\n     - 另一种方法是Mediator中定义一个特殊的通知接口，各Colleague在通信时直接调用该接口\n\n**应用实例**\n\n- `java.util.Timer` (all scheduleXXX() methods)\n- `java.util.concurrent.Executor#execute()`\n- `java.util.concurrent.ExecutorService` (the invokeXXX() and submit() methods)\n- `java.util.concurrent.ScheduledExecutorService` (all scheduleXXX() methods)\n- `java.lang.reflect.Method#invoke()`\n"}