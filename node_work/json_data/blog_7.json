{"text":"###JVM内存区域划分###\nJVM内存分为线程私用和线程共享两种不同类型的内存区域。\n![Alt text](http://img.blog.csdn.net/20141116170313124)\n**线程私用内存**包括：程序计数器、Java方法栈、本地方法栈；\n\n- 程序计数器：当前指令的地址，若当前方法是native则PC是undefined。\n- Java方法栈：线程的每个方法持有一个frame用于在该线程上执行。当方法被调用的时候，在Stack顶部创建一个新的frame，当方法调用结束frame将会被移除。\n- 本地方法栈：并非所有的线程支持本地方法，但是通常都会创建一个本地方法栈。\n\n**线程共享内存**包括：堆、方法区\n\n- 堆：堆用于存放运行时的对象实例和数组。数组和对象不能存在stack中，因为stack的frame是创建以后固定大小，frame只存放对象或数组的引用，因此当方法结束时，对象只能等待GC回收。为了支持GC，堆区域分为：Yong Generation、Old Generation、Permanent Generation\n- Non-Heap Memory：用于存放逻辑上认为JVM机制一部分而非在堆上创建的对象\n    - Permanent Generation：method area、interned strings\n    - Code cache：用于存放被JIT编译本地代码的方法\n- 方法区存放每个类的信息\n    - Classloader Reference\n    - Run Time Constant Pool：Numeric constants、Field reference、Method refrence、Attributes\n    - Filed data：Name、Type、Modifier、Attributes\n    - Method data：Name、Return Type、Parameter Type、Modifiers、Attributes\n    - Method code：Bytecodes、Operand stack size、Local Variable size、Exception table\n\n###堆内存###\nJDK8中对内存结构如下图所示，主要两个区域，**年轻代和终生代** (取消了永久代)。其中年轻代由两个区域:一个**Eden**区和两个**Survivor**区组成。新的对象总是放在Eden区，Survivor区作为Eden区和Tenure(终生代)的缓冲。\n当-Xms初始堆内存大小设置的值小于-Xmx最大堆内存时，不会一次分配所有内存，还会有部分内存当需要的时候再分配，图示Virtual部分。\n![Alt text](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_006_prm_gn_sz.png)\nNewRatio参数可以控制年轻代和终生代内存的比例，默认为1:3，其中年轻代占总内存的1/4。\nSurvivorRatio参数可以控制Eden区和Survior区的比例，-XX:SurvivorRatio=6表示一个Survivor占Eden区的1/6，占整个年轻代的1/8。\n**内存分配与回收策略**\n\n- 对象优先分配在Eden分配\n- 大对象直接进入老年代，大对象指需要大量连续内存空间的java对象，如长字符串数组\n- 长期存活的对象将进入老年代\n    - 虚拟机采用分代收集思想管理内存，必须有一种机制判断对象年代。\n    - 虚拟机给每个对象定义了一个对象年龄的计数器。若对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor中，并将对象年龄设为1。对象没在Survivor区中每熬过一次Minor GC年龄加1，当年龄达到一定程度（默认15），就会晋升到老年区。\n    - 若在Survivor中相同年龄所有对象大小和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。\n    - 分配担保，发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于则查看HandlePromotionFailure设置是否允许担保失败;若允许只会进行Minor GC；若不允许，则也要进行 Full GC。\n\n###Java对象的内存结构###\njava中对象分配在堆空间中，具体一个对象占用多大的内存呢？首先，任何一个对象都对应一个类型这个类型本身是Class对象，但Class对象包含很多信息，占用空间较大以KB为单位，因此每个对象在头部包含一个指针指向这个Class对象。此外对象头部还有一个`Mark Word`用来存放：是否加锁、GC标志位、Monir GC次数、对象的默认hashCode等信息。\n\n在32位系统中Class指针占用4个字节，`Mark Word`占用4个字节，因此头部占8个字节。此外Java对象是8字节对齐的，也就是以8字节为内存访问的基本单元，那么在地址处理上，就有3个位是空闲的可以用于虚拟。总体来说，对象内存结构包括以下部分：`Mark Word`，Class指针，对象body部分，对齐字节。\n\n以32位系统为例，`new Object()`(没有任何属性)，JVM将分配8个字节空间。`new Integer()`对象内部包含一个4B的int数据，占用空间为4+4+4+4=16B。\n\n对象内部属性分布规则:\n\n- 没有继承的对象属性排布。默认情况下按照：long/double -> int/float -> byte/boolean -> Refrence。此外静态属性所占用的空间通常不计算到对象本身的空间上，因为它的引用是在方法区。\n- 有继承的对象属性排布。父类和子类的属性分别单独排布，不能混在一起，且要求8字节对齐。例如单层继承分布如下：`Mark Word`，Class指针，父类的属性，属性对齐，当前类的属性，整个对象对齐。\n\n###对象嵌套\n对象嵌套是对象内部有引用指向了其他的对象，并且是一层嵌套一层。嵌套层次越深，中间浪费的内存就越多。java中实际多维数组都是嵌套一维数组构成的。`int a[2][100]`是由两个和`int a[100][2]`在32位系统中占用内存大小。\n\n- `int a[2][100]`看成是嵌套对象int[100]，第一维数组长度是2占用内存是：\n对象头部8B+数组长度4B+实际引用2*4B+对齐4B=24B。最多两个子数组，每个子数组大小：\n对象头部8B+数组长度4B+实际引用100*4B+对齐4B=416B。\n整个数组大小：24B+2*416B=856B。\n- `int a[100][2]`，第一维数组长度是100占用内存是：\n对象头部8B+数组长度4B+实际引用100*4B+对齐4B=416B。最多100个子数组，每个子数组大小：\n对象头部8B+数组长度4B+实际引用2*4B+对齐4B=24B。\n总大小416B+100*24B=2816B。\n`int a[100][2]`实际比`int a[2][100]`浪费近2倍的内存，主要由于引用100个小的一维数组比2个大的一维数组相对更浪费空间。"}