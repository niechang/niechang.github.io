{"text":"###阻塞和非阻塞、同步和异步###\n按照《Unix网络编程》的划分，IO模型可以分为：**阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO**，按照POSIX标准来划分只分为两类：**同步IO和异步IO**。如何区分呢？\n\n首先一个IO操作其实分成了两个步骤：**发起IO请求和实际的IO操作**。\n\n**阻塞IO和非阻塞IO**的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的**阻塞IO**，如果不阻塞，那么就是**非阻塞IO**。\n**同步IO和异步IO**的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。\n\n**同步和异步**的概念,这两个概念与消息的通知机制有关。同步消息处理中，等待者会一直轮询判断事件否完成；在异步消息处理中,等待消息者往往注册一个回调机制,在所等待的事件被触发时由触发机制通过某种机制找到等待该事件的注册者。\n**同步和异步**是针对应用程序和内核的交互而言的，**同步**指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而**异步**是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。\n**阻塞和非阻塞**是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 \n**同步和异步**是相对于应用和内核的交互方式而言的，同步需要主动去询问，而异步的时候内核在IO事件发生的时候通知应用程序，**而阻塞和非阻塞**仅仅是系统在调用系统调用的时候函数的实现方式而已。\n\n###I/O模型###\n Linux上可以使用的不同I/O模型如下图所示，下面这部分摘自[IBM技术社区](http://www.ibm.com/developerworks/cn/linux/l-async/)。\n![Alt text](http://img.blog.csdn.net/20141116214137758)\n\n- **同步阻塞I/O**\n用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。\n- **同步非阻塞I/O**\n同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。\n非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。\n- **异步阻塞I/O**\n另外一个阻塞解决方案是带有阻塞通知的非阻塞 I/O。在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 select 系统调用来确定一个 I/O 描述符何时有操作。使 select 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。\n- **异步非阻塞 I/O（AIO）**\n异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 read 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 read 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。\n\n###BIO、NIO和AIO浅析###\n实际IO操作可以分为3类：同步阻塞（即早期的BIO操作）、同步非阻塞（NIO）、异步（AIO）\n\n- 同步阻塞(BIO)： 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。简单理解：**一个连接一个线程**。\n- 同步非阻塞(NIO)： 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。Java中NIO由缓冲区（Buffers）、通道（Channels）和非阻塞IO的核心类组成，一般说NIO是指非阻塞IO。NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。简单理解：**一个请求一个线程**。\n- 异步(AIO)： 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。简单理解：**一个有效请求一个线程**。\n    - AsynchronousSocketChannel\n    - AsynchronousServerSocketChannel\n    - AsynchronousFileChannel\n    - AsynchronousDatagramChannel\n\n**Java NIO和BIO的区别**\n\n- BIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。\n- BIO当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。\n- Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。\n\n| BIO |NIO|\n|---|---|\n| 面向流 | 面向缓冲  |\n|阻塞IO|非阻塞IO|\n|无|选择器|\n\n**应用场景**\n\n**BIO**方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 \n**NIO**方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 \n**AIO**方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 \n\n**底层实现**\n\nAIO在windows平台通过`IOCP`实现，linux默认是`epoll`实现。\n\n###Reactor和Proactor\n高性能I/O中常用两种模式Reactor和Preactor，这部分摘自[博客](http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html)。\n一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。两个与事件分离器有关的模式是Reactor和Proactor。\n**Reactor模式**采用**同步IO**，而**Proactor**采用**异步IO**。\n\n两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。\n\nReactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备."}