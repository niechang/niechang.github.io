{"text":"###创建者模式\n**意图**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n**适用性**\n\n- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。\n-  当构造过程必须允许被构造的对象有不同的表示时。\n\n**结构**\n![builder pattern][1]\n**参与者**\n\n- Builder：为创建一个Product对象的各个部件指定抽象接口\n- ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件; 定义并明确它所创建的表示; 提供一个检索产品的接口\n- Director：构造一个使用Builder接口的对象\n- Product：表示被构造的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程。包含定义组成部件的类，包括将这些部件装配成最终产品的接口。\n\n**协作**\n\n- 客户创建 Director对象，并用它所想要的 Builder对象进行配置。\n- 一旦产品部件被生成，导向器就会通知生成器。\n- 生成器处理导向器的请求，并将部件添加到该产品中。\n- 客户从生成器中检索产品\n![builder pattern flow][2]\n\n**效果**\n\n- 它使你可以改变一个产品的内部表示\n- 它将构造代码和表示代码分开 \n- 它使你可对构造过程进行更精细的控制\n\n**相关模式**\nAbstract Factory与 Builder 相似，因为它也可以创建复杂对象。主要的区别是\nBuilder 模式着重于一步步构造一个复杂对象。而 Abstract Factory着重于多个系列的产品对象（简单的或是复杂的）。Builder 在最后的一步返回产品，而对于 Abstract Factory来说，产品是立即返回的。\nComposite通常是用Builder 生成的。\n\n###JDK中Builder模式实例\nBuilder (recognizeable by creational methods returning the instance itself)\n\n- ` java.lang.StringBuilder#append() `(unsynchronized)\n-  `java.lang.StringBuffer#append() `(synchronized)\n-  `java.nio.ByteBuffer#put()` (also on CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer and DoubleBuffer)\n-  `javax.swing.GroupLayout.Group#addComponent()`\n- All implementations of `java.lang.Appendable`\n\n\n  [1]: http://img.itc.cn/photo/jtJxI6Fm9Of\n  [2]: http://img.itc.cn/photo/jtJAx8PAkLz"}