{"text":"###线程简介\n\n**线程**：\n\n- 操作系统需要运行程序必须创建进程，一个进程至少包含一个线程\n- 操作系统最小的调度单元\n- 线程拥有自己的局部变量、栈和程序计数器等\n\n**多线程优势**\n\n- 可以在同一刻做不同的事情\n- 在单处理器下操作系统也可以模拟多个线程轮询执行，造成并行执行的效果\n- 多核处理器更加具有优势，并行执行\n\n**多线程劣势**\n\n- 线程本身存在开销，过多的线程造成操作系统上下文切换负载变大\n- 启动、终止和销毁一个线程都会占用开销\n- 多线程需要考虑线程安全和竞态条件\n\nJava创建线程两种方式\n\n- 继承Thread类、\n- 实现Runnable通过Thread包装\n\n**中断**是线程之间一种协作机制一般用于终止某个线程，通过`isInterrupted()`判断是否发生中断，`Thread.interrupted()`清除中断，`Thread.sleep()`等方法若被中断则会抛出`InterruptedException`，同时当前线程的中断状态也会被清除。\n阻塞于同步I/O的线程被中断后，中断标识被打上，但是不会抛出 `InterruptedException`。\n`interrupted()`操作对于线程处于BLOCKED和RUNNABLE状态是无效的，只有当线程处于WAITING或TIME_WAITING状态时有用，让它们实质性的抛出异常。\n\n查看线程信息：jstack pid\n\n**线程优先级**：java中线程优先级范围从1到10，但是程序不要依赖于优先级设置，这样代码会和平台相关，同时不一定能达到期望效果。\n\n**线程状态**：`java.lang.Thread$State`中定义了线程状态包括NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED。\n\n- NEW，新建状态，还没开始的线程(未调用start()方法)\n- RUNNABLE，运行状态`Thread.currentThread.getState()`只会返回运行状态，所以一般都是获取其他线程的状态。并不一定正在CPU上运行，也可能是在等待操作系统其它资源如CPU等。\n- BLOCKED，阻塞状态，线程已经挂起，原因通常是它在等待一个锁。一般可以分为阻塞于IO和阻塞于同步两种。\n- WAITING，等待状态，通常指线程拥有对象锁后进入到相应的代码区域后，调用相应的锁对象的wait操作产生的结果，变相的实现还有LockSupport.park()、Thread.join()等。\n- TIMED_WAITING，有限等待，如Thread.sleep(long)、Object.wait(long)、LockSupport.parkNanos(long)等\n- Terminated，终结状态，run()方法运行结束\n![thread state](http://img.itc.cn/photo/j3JpEkBQZFn)\n\n**wait和notify必须使用synchronzied？**\nwait和notify实现基础是基于对象存在的，常见写法如下。\n```\nsynchronized(object){\n    object.wait();\n}\n```\n由于是基于对象存在的，必须用一个数据结构来存储这些等待的线程，而且这个数据结构应该是与该对象绑定的(C++代码可以发现是一个双向链表数据结构)，此时这个对象上可以有多个线程wait/notify方法。在向这个双向链表插入、删除数据时，依然是个并发问题需要加锁，在JVM内核中并没有发现加锁的操作，由此可见加锁动作由java程序这个抽象层次来完成，所以必须使用synchronized。wait操作会立即释放锁，但是notify不会。\n\n**wait和sleep的区别？**\nwait和sleep都会让出CPU使得线程进入等待状态，但是wait操作时定义在Object对象上，sleep是定义在Thread对象上，且wait操作必须结合synchronized使用并会释放持有的锁，而sleep若持有锁则不会释放。\n\n**并发访问**\n\n- volatile实现弱一致性的同步语义\n- syncrhonized内置锁\n- `java.util.concurrent.Lock`的子类，自定义锁对象\n- 同步容器`Collections.synchronizedXxx()`、`Vector`、`Hashtable`\n- 并发容器`CopyOnWriteArrayList`、`ConcurrentHashMap`、`BlocingQueue`\n\n**线程间通信**\n\n- 等待/通知机制(wait/notify)\n - wait和notify方法必须在同步块中调用，wait方法会释放占用的锁，notify方法不会释放对象的锁\n- 管道`PipeInputStream`，`PipeOutputStream`，`PipedReader`,`PipeWriter`。Piped类型的流，必须要进行connect，如果没有绑定，对于该流的访问会抛出异常。\n- `thread.join`方法会等待所有线程结束才继续\n\n###参考资料\n[java并发编程1.2时代](http://ifeve.com/java_multi_thread_programming_1_2/)\n[Java多线程发展简史](http://blog.jobbole.com/28297/)"}