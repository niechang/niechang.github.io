{"text":"###集合类总览\n集合类可以分为单线程(`java.util`包下)和多线程(`java.util.concurrent`包下)两种版本。\n接口 | 单线程集合类 | 多线程集合类 \n-----------|------------|------------\n List   | ArrayList：数组实现的List | CopyOnWriteArrayList：修改时创建一个副本，用于读远远大于写的情况\n List   | LinkedList：双向链表实现的List| \n List   | Vector：同步版本已经废弃| \n Queue/Dequeue   | ArrayDeque：采用数组实现的顺序双端队列|ArrayBlockingQueue：带边界的阻塞式队列  \n Queue/Dequeue   | PriorityQueue：基于小根堆(数组实现)的优先级队列|PriorityBlockingQueue：并发PriorityQueue  \n Queue/Dequeue   | Stack：已废弃|ConcurrentLinkedDeque：无边界的链表队列（CAS）\n Queue/Dequeue   | | DelayQueue：元素带有延迟的队列\n Queue/Dequeue   | | LinkedBlockingQueue：链表队列（带锁），可设定是否带边界\n Queue/Dequeue   | | LinkedTransferQueue：可将元素transfer进行w/o存储\n Queue/Dequeue   | | SynchronousQueue：使用Queue接口进行Exchanger\n Map  |HashMap：采用数组和链表方式实现的散列表(链式冲突解决法) | ConcurrentHashMap：通用并发Map\n Map  |EnumMap：键使用enum，采用数组实现| \n Map  |Hashtable：已废弃| \n Map  |IdentityHashMap：键使用==进行比较,数组实现(线性探测)| \n Map  |LinkedHashMap：保持插入顺序，双向链表记住插入顺序|\n Map  |TreeMap：键已排序，红黑树实现| ConcurrentSkipListMap：已排序的并发Map\n Map  |WeakHashMap：适用于缓存cache，key值封装为WeakReference| \n Set  |HashSet：通用set，利用HashMap实现| CopyOnWriteArraySet：几乎不更新，通常只做遍历\n Set  |EnumSet：元素为enum，利用数组实现| \n Set  |LinkedHashSet：保持插入顺序，LinkedHashMap实现|\n Set  |TreeSet：排序Set，利用TreeMap实现| ConcurrentSkipListSet：排序并发Set\n\n单线程容器包括：同步容器`Vector`、`Hashtable`、`Collections.synchronizedXxx`返回的容器；非线性安全容器`ArrayList`、`HashMap`等大部分类。\n多线程容器又称做并发容器，是由于替换同步容器，获取更高的并发性能和吞吐量。\n\n###并发容器\nJava5.0提供多种并发容器来改进同步容器的性能。同步容器将所有对容器状态访问都进行串化，来实现它们的线程安全性。这种方式的代价是严重降低了并发性。**通过并发容器代替同步容器，可以极大的提高伸缩性并降低风险**。\n`ConcurrentHashMap`代替基于散列的`Map`，`CopyOnWriteArrayList`代替同步的`List`。\nJava5.0新增两种容器类型：`Queue`和`BlockingQueue`。\n\n- `Queue`用来临时保存一组等待处理的元素，它提供几种实现：`ConcurrentLinkedQueue`传统的先进先出队列和`PriorityQueue`非并发地优先队列。Queue上的操作不会阻塞，若队列为空返回空值。虽然可以同List来模拟Queue的行为，事实上正是通过LinkedList来实现Queue但还需要一个单独Queue接口，屏蔽掉List的随机访问接口实现更高效的并发。\n- `BlockingQueue`扩展了`Queue`，增加了可阻塞的插入和获取操作，若队列为空，那么获取元素的操作一直阻塞，直到队列中出现可用的元素。若队列已满(对于有界队列)，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。在生产者-消费者设计模式中，阻塞队列非常有用。\n\n**ConcurrentHashMap**\n`ConcurrentHashMap`并不是像同步容器类那样将每个方法都在同一个锁上同步并使得只有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制成为**分段锁(Lock Striping)**。在这种机制下，任意数量的读取线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。`ConcurrentHashMap`在并发环境下实现更高的吞吐量，而在单线程环境下只损失非常小的性能。\n`ConcurrentHashMap`和其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出并发修改异常，因此不需要迭代过程中加锁。其迭代器具有弱一致性，而非及时失败`fail-fast`。\n`ConcurrentHashMap`一些操作需要权衡，对于一些需要在整个Map上进行计算的方法，例如size和isEmpty，这些方法的语义被略微减弱以反映容器的并发特性，size返回结果在计算时可能已经过期，实际只是一个估计值，因此只能看做是一个近似值而非精确值。实际并发环境下，这些方法的返回值在不断变化，因此应用比较少。\n由于`ConcurrentHashMap`不能被加锁执行独占访问，其本身实现的接口`ConcurrentMap`中提供一些常见的复合操作，如\"若没有则添加\"、\"若相等则移除\"、\"若相等则替换\"。\n```\npublic interface ConcurrentMap<K,V> extends Map<K,V> {\n//仅当没有时才插入\nV putIfAbsent(K key, V value);\n//仅当key映射到value时才删除\nboolean remove(K key, V value);\n//仅当key映射到oldValue的时候才替换为newValue\nboolean replace(K key, V oldValue, V newValue);\n//仅当key映射到某个值的时候才替换为newValue\nboolean replace(K key, V newValue)\n}\n```\n\n**CopyOnWriteArrayList**\nCopyOnWriteArrayList用于替换同步的List，在某些情况下提供更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。CopyOnWriteArraySet代替同步Set。\n\"写入时复制\"容器线程安全在于，只要正确的发布一个事实不可变的对象时，那么在访问该对象时不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。\n\"写入时复制\"容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此对其进行同步时只需要确保数组内容的可见性(源码中数组声明为volatile )。其迭代器不会抛出并发修改异常，且和其创建时的元素完全一致，不必考虑之后修改操作带来的影响。\n\"写入时复制\"容器需要一定的开销用于复制数组，特别是当容器规模特别大的时候。一般用于迭代操作远远大于修改操作时，才使用\"写入时复制\"容器。\n###阻塞队列和生产者-消费者模式\n阻塞队列提供put和take方法，以及支持定时的offer和poll方法。若队列已满，则put方法将阻塞直到有空间可用；若队列为空，则take方法将阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远不会填满，因此其put方法永远不会阻塞。\n阻塞队列支持生产者-消费者模式，将\"找出需要完成的工作\"和\"执行工作\"这两个过程分离开来，并把工作放入一个待完成的列表中，随后处理。BlockingQueue简化生产者和消费者模式的实现过程，支持任意数量的生产者和消费者，生产者把数据放入队列中，而消费者准备处理数据时，将从队列中获取数据。一种最常见的生产者-消费者设计的模式是线程池与工作队列的组合，在Executor任务执行框架中体现这种设计模式。\nBlockingQueue有多种实现包括：\n\n- `LinkedBlockingQueue`和`ArrayBlockingQueue`是FIFO队列，二者分别与LinkedList和ArrayList类似，但比List拥有更好的并发性能\n- `PriorityBlockingQueue`是一个按优先级排列的队列，当希望按照某种顺序而非FIFO来处理元素时，这个队列非常有用。\n- `SynchronousQueue`实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同，其维护一组线程，这些线程在等待着把元素加入或移出队列。由于其采用直接交付工作方式，降低了数据从生产者移动到消费者的延迟。由于没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总有一个消费者准备好获取交付的工作时，才适合使用同步队列。\n\n###参考文献\n[Java集合总览][1]\n\n\n [1]: http://www.importnew.com/13801.html"}