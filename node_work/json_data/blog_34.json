{"text":"###线程安全性\n线程的优势：\n\n- 发挥多核处理器的强大能力\n- 建模的简单性\n- 异步事件的简化处理(和NodeJS相反)\n- 响应更灵敏的用户界面\n\nJava中线程无处不在：Timer、Servlet、RMI、Swing和AWT。\n\nJava中\"同步\"术语包括的内容：内置锁**synchronzide、volatile变量、显示锁、原子变量**。\n\n**线程安全性**：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，我们就称这个类是线程安全的。\n\n无状态的对象一定是线程安全的。\n\n内置锁都是可重入，\"重入\"意味着获取锁的操作的粒度\"线程\"，而不是\"调用\"。\n\n**加锁的含义不仅仅局限于互斥行为，还包括内存可见性**。因此为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程必须在同一个锁上同步。\n\nvolatile变量提供一种稍弱的同步机制，用来保护将变量的更新操作通知给其他线程，保证内存可见性。\n把变量声明为volatile，编译器和运行时都会注意到这个变量是共享的，不会将该变量上的操作与其他内存操作一起重排序。\nvolatile典型用法：检查某个状态标记以判断是否退出循环。\n\n###对象的共享\n**发布**：使对象可以在当前作用域以外的代码中使用。\n**逸出**：当某个不该发布的对象被发布\nthis引用逸出的常见情况：在构造函数中启动一个线程，this引用会被新创建的线程所共享。\n\n**线程封闭**：一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭。\n\n- Ad-hoc线程封闭：维护线程封闭性的职责完全由程序实现来控制。这种方式非常脆弱，因为没有任何一种语言特性，例如可见性或局部变量，能将对象封闭到目标线程上。通常线程封闭对象的引用保存在公有变量中。\n- 栈封闭：只能通过局部变量才能访问的对象。局部变量封闭在执行线程中。\n- ThreadLocal类：这个类能使线程中某个值域保存值得对象关联起来，其提供get和set方法，这些方法为每个使用该变量的线程都存有一份副本。特定于线程的值保存在Thread对象中，当线程终止将会被回收。\n\n**不变性**\n满足线程安全的另一种方法是使用不可变对象(Immutable Object)。满足不可变性对象的条件：\n\n- 对象创建以后其状态不能修改\n- 对象的所有都是final类型\n- 对象是正确发布的(对象创建期间没有this逸出)\n\n**安全发布的常用模式**：\n\n- 在静态初始化函数中初始化对象的引用\n- 将对象的引用保存到volatile类型的域或者AtomicReference对象中\n- 将对象的引用保存到某个正确构造对象的final类型域中\n- 将对象的引用保存到一个由锁保护的域中\n\n线程安全的容器和其他数据传递机制提供安全发布的保证包括：\n\n- Hashtable、synchronizedMap或者ConcurrentHashMap可以安全的将发布给任何从这些容器访问它的线程\n- Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet\n- BlockingQueue、ConcurrentLinkedQueue\n- 类库中其他数据传递机制如Future和Exchanger同样可以实现安全的发布\n\n###基础构建模块\n**同步容器**\nJDK中同步容器：`Vector`、`Hashtable`、`Collections.synchronizedXxx()`等工厂方法返回的容器。这些类通过将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。\n同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器常见的复合操作包括：迭代、跳转、条件运算，这些复合操作在客户端没有加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能出现意料之外的行为。例如：一个线程正在取最后一个元素，另一个线程将其删除，导致前一个线程访问越界。\n**迭代器和ConcurrentModification**\n同步容器无法在迭代的时候检测到容器结构是否发生变化，但是同步容器支持一种`及时失败fail-fast`的迭代策略，在迭代过程若发现容器结构发生修改，则抛出`ConcurrentModification`。当然可以通过在迭代的时候对容器进行加锁避免并发修改异常，但是这样会使得其他线程长时间等待。\n若不希望迭代期间加锁，可以拷贝一份容器，并在副本上面进行遍历，就像`CopyOnWriteArrayList`这样，不过该容器是在集合本身发生结构修改的时候创建一个副本，这种情况拷贝的时候会带来较大的性能开销。\n**隐藏迭代器** \n当采用加锁的方式迭代来避免并发修改异常的时候，需要注意一些隐藏迭代器调用的情况。若容器的调用自身的`toString()`方法。容器的`hashCode`、 `equals`、 `containsAll`、 `removeAll`和`retainAll`这些方法都会间接的执行迭代操作。\n\n**并发容器**\n Java5.0提供多种并发容器来改进同步容器的性能。同步容器将所有对容器状态访问都进行串化，来实现它们的线程安全性。这种方式的代价是严重降低了并发性。**通过并发容器代替同步容器，可以极大的提高伸缩性并降低风险**。\n`ConcurrentHashMap`代替基于散列的`Map`，`CopyOnWriteArrayList`代替同步的`List`。\n Java5.0新增两种容器类型：`Queue`和`BlockingQueue`。\n\n - `Queue`用来临时保存一组等待处理的元素，它提供几种实现：`ConcurrentLinkedQueue`传统的先进先出队列和`PriorityQueue`非并发地优先队列。Queue上的操作不会阻塞，若队列为空返回空值。虽然可以同List来模拟Queue的行为，事实上正是通过LinkedList来实现Queue但还需要一个单独Queue接口，屏蔽掉List的随机访问接口实现更高效的并发。\n - `BlockingQueue`扩展了`Queue`，增加了可阻塞的插入和获取操作，若队列为空，那么获取元素的操作一直阻塞，直到队列中出现可用的元素。若队列已满(对于有界队列)，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。在生产者-消费者设计模式中，阻塞队列非常有用。\n\n**ConcurrentHashMap**\n`ConcurrentHashMap`并不是像同步容器类那样将每个方法都在同一个锁上同步并使得只有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制成为**分段锁(Lock Striping)**。在这种机制下，任意数量的读取线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map。`ConcurrentHashMap`在并发环境下实现更高的吞吐量，而在单线程环境下只损失非常小的性能。\n`ConcurrentHashMap`和其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出并发修改异常，因此不需要迭代过程中加锁。其迭代器具有弱一致性，而非及时失败`fail-fast`。\n`ConcurrentHashMap`一些操作需要权衡，对于一些需要在整个Map上进行计算的方法，例如size和isEmpty，这些方法的语义被略微减弱以反映容器的并发特性，size返回结果在计算时可能已经过期，实际只是一个估计值，因此只能看做是一个近似值而非精确值。实际并发环境下，这些方法的返回值在不断变化，因此应用比较少。\n**额外的原子操作**\n由于`ConcurrentHashMap`不能被加锁执行独占访问，其本身实现的接口`ConcurrentMap`中提供一些常见的复合操作，如\"若没有则添加\"、\"若相等则移除\"、\"若相等则替换\"。\n```\npublic interface ConcurrentMap<K,V> extends Map<K,V> {\n    //仅当没有时才插入\n    V putIfAbsent(K key, V value);\n    //仅当key映射到value时才删除\n    boolean remove(K key, V value);\n    //仅当key映射到oldValue的时候才替换为newValue\n    boolean replace(K key, V oldValue, V newValue);\n    //仅当key映射到某个值的时候才替换为newValue\n    boolean replace(K key, V newValue)\n}\n```\n**CopyOnWriteArrayList**\n`CopyOnWriteArrayList`用于替换同步的List，在某些情况下提供更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。`CopyOnWriteArraySet`代替同步Set。\n\"写入时复制\"容器线程安全在于，只要正确的发布一个事实不可变的对象时，那么在访问该对象时不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。\n\"写入时复制\"容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此对其进行同步时只需要确保数组内容的可见性(源码中数组声明为volatile )。其迭代器不会抛出并发修改异常，且和其创建时的元素完全一致，不必考虑之后修改操作带来的影响。\n\"写入时复制\"容器需要一定的开销用于复制数组，特别是当容器规模特别大的时候。一般用于迭代操作远远大于修改操作时，才使用\"写入时复制\"容器。\n\n**阻塞队列和生产者-消费者模式**\n阻塞队列提供put和take方法，以及支持定时的offer和poll方法。若队列已满，则put方法将阻塞直到有空间可用；若队列为空，则take方法将阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远不会填满，因此其put方法永远不会阻塞。\n阻塞队列支持生产者-消费者模式，将\"找出需要完成的工作\"和\"执行工作\"这两个过程分离开来，并把工作放入一个待完成的列表中，随后处理。BlockingQueue简化生产者和消费者模式的实现过程，支持任意数量的生产者和消费者，生产者把数据放入队列中，而消费者准备处理数据时，将从队列中获取数据。一种最常见的生产者-消费者设计的模式是线程池与工作队列的组合，在Executor任务执行框架中体现这种设计模式。\nBlockingQueue有多种实现包括：\n\n- `LinkedBlockingQueue`和`ArrayBlockingQueue`是FIFO队列，二者分别与LinkedList和ArrayList类似，但比List拥有更好的并发性能\n- `PriorityBlockingQueue`是一个按优先级排列的队列，当希望按照某种顺序而非FIFO来处理元素时，这个队列非常有用。\n- `SynchronousQueue`实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同，其维护一组线程，这些线程在等待着把元素加入或移出队列。由于其采用直接交付工作方式，降低了数据从生产者移动到消费者的延迟。由于没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总有一个消费者准备好获取交付的工作时，才适合使用同步队列。\n\n**双端队列与工作密取**\nJava6中增加了两种容器类型：`Dequeue`和`BlockingDeueue`分别对`Queue`和`BlockingQueue`进行了扩展。Dequeue是一个双端队列，实现了在队列头和尾高效插入和移除，具体实现包括：`ArrayDeque`和`LinkedBlockingDeque`。\n双端队列使用于一种**工作密取(Work Stealing)**模式，在工作密取模式中，每个消费者都有一个各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者的双端队列末尾秘密的获取工作。密取工作模式比传统的生产者消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享任务队列上发生竞争。\n工作密取非常适用于既是消费者也是生产者问题：当执行某个工作时可能导致出现更多的工作。\n\n**同步工具类**\n阻塞队列是一种特殊的类：既可以作为保存对象的容器，又可以协调生产者和消费者等线程之间的控制流，作为同步工具类。其他同步工具类包括：信号量(Semaphore)、栅栏(Barrier)以及闭锁(Latch)。\n**闭锁**\n闭锁是一种同步工具类，**可以延迟线程的进度直到其到达终止状态**。闭锁的作用相当一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有线程可以通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。闭锁到达结束状态以后，将不会再改变状态，因此这扇门永远保持打开。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。\n\n- 确保某个计算在其需要的所有资源都初始化之后才继续执行。\n- 确保某个服务在其他依赖的所有其他服务都已经启动之后才启动。\n- 等待直到某个操作的所有参与者都就绪再继续执行。\n\n`CountDownLatch`是一种灵活的闭锁实现，闭锁状态包括一个计数器，该计数器初始化为一个正数，表示需要等待的事件数量，`countDown`方法递减计数器，表示有一个事件已经发生，`await`方法等待计数器达到零，表示所有需要等待的事件都已经发生。\n\n`FutureTask`也可以用作闭锁，表示一种抽象的可生成结果的计算。`FeatureTask`表示的计算是通过`Callable`来实现的，一种可生成返回结果的`Runnable`，并且可以出于以下3种状态：等待运行、正在运行、运行完成。其`get`方法的行为取决于任务的状态，如果任务已经完成，那么会立即返回结果，否则将会阻塞直到任务进入完成状态，然后返回结果或者抛出异常。`FutureTask`将计算结果从执行计算的线程传递到获取这个结果的线程，而`FutureTask`的规范确保了这种传递过程能实现结果的安全发布。\n\n**信号量**\n计算信号量(Counting Semaphore)用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。\n`Sempahore`中管理着一组虚拟的许可(permit)，许可的初始数量可通过构造函数来指定。在执行操作时可以先获得(acquire)许可，并在使用以后释放(release)许可。如果没有一个许可给信号量，那么acquire将阻塞直到有许可，release方法将返回一个许可给信号量。\n计算信号量的一种简化形式是二值信号量，即初始值为1的`Semaphore`。二值信号量可以用做互斥体(mutex)，并具备不可能重入的加锁语义：谁拥有这个唯一的许可，谁就用拥有了互斥锁。\n\n**栅栏**\n栅栏(Barrier)类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的区别在于所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，栅栏用于等待其他线程。闭锁是一次性对象，一旦进入终止状态，不能被重置。`CyclicBarrier`可以使一定数量的参与方反复在栅栏位置汇集。`Exchanger`是一种两方的栅栏，各方在栅栏位置上交换数据。\n\n| Class      |  Description |\n| :-------- | --------|\n|CountDownLatch |在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。只出现一次，计数无法被重置 |\n| Semaphor     |信号量，根据一些阀值做访问控制 |\n| CyclicBarrier      |它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)需要所有的子任务都完成时，才执行主任务，可以被重用 |\n|Exchanger|线程之间交互数据，且在并发时候使用，两两交换，交换中不会因为线程多而混乱，发送出去没接收到会一直等，由交互器完成交互过程 |\n\n**构建高效可伸缩的结果缓存**\n**version 1**：内置锁同步机制，问题：阻塞其他线程，伸缩性差\n```\npublic class Memoizer<A,V> implements Computable<A, V> {\n    private final Map<A, V> cache = new HashMap<A, V>();\n    private final Computable<A, V> c;\n    \n    public synchronized V compute(A arg) {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return result;\n    }\n}\n```\n**version 2**：using `ConcurrentHashMap`，问题：可能存在两个线程重复计算相同的值\n```\npublic class Memoizer<A,V> implements Computable<A, V> {\n    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();\n    private final Computable<A, V> c;\n     \n    public V compute(A arg) {\n        V result = cache.get(arg);\n        if (result == null) {\n            result = c.compute(arg);\n            cache.put(arg, result);\n        }\n        return result;\n    }\n}\n```\n**version 3**：基于FutureTask，若缓存中没有，则创建一个FutureTask，若仍在计算，其他线程调用FutureTask.get将会阻塞。问题：由于if代码块是非原子操作，仍然有较小的几率重复计算。\n```\npublic class Memoizer<A,V> implements Computable<A, V> {\n    private final Map<A, V> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computable<A, V> c;\n     \n    public V compute(A arg) {\n        Future<V> f = cache.get(arg);\n        if (f == null) {\n            Callable<V> eval = new Callable<V>() {\n                public void call() {\n                    return c.compute(arg);\n                }\n            }\n            FutureTask<V> ft = new FutureTask<V>(eval);\n            f = ft;\n            cache.put(arg, ft);\n            ft.run(); //调用c.compute\n        }\n        try{\n            return f.get();\n        }catch(ExecutionException e) {\n        }\n    }\n}\n```\n**version 4**:复合操作，利用ConcurrentMap的原子方法putIfAbsent\n```\npublic class Memoizer<A,V> implements Computable<A, V> {\n    private final Map<A, V> cache = new ConcurrentHashMap<A, Future<V>>();\n    private final Computable<A, V> c;\n     \n    public V compute(A arg) {\n        Future<V> f = cache.get(arg);\n        if (f == null) {\n            Callable<V> eval = new Callable<V>() {\n                public void call() {\n                    return c.compute(arg);\n                }\n            }\n            FutureTask<V> ft = new FutureTask<V>(eval);\n            f = cache.putIfAbsent(arg, ft);\n            if(f == null) {\n                f = ft;\n                ft.run(); //调用c.compute\n            }\n        }\n        try{\n            return f.get();\n        }catch(ExecutionException e) {\n        }\n    }\n}\n```\n"}