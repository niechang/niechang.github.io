{"text":"###线程活跃性危险\n**锁顺序死锁(Lock-Ordering Deedlock)**：当有两个或多个锁，某个请求操作需要按照一定次序获取这些锁对象时，若存在多个线程获取锁的顺序不一致则很可能导致这类锁顺序死锁。\n如果能保证所有的线程以固定的顺序来获得锁，则在程序中可以避免锁顺序死锁。\n对于动态的锁顺序死锁，为了确保按照某个固定的顺序时，可以使用`System.identityHashCode`方法\n```\ntransfer(myAccount, yourAccount, 10)\ntransfer(yourAccount, myAccount, 20)\nprivate static final Object tieLock = new Object();\npublic void transfer(final Account from, final Account dest, final int num) {\n    int fromHash = System.identityHashCode(from);\n    int toHash = System.identityHashCode(dest);\n    if(fromHash < toHash) {\n        synchronized(from) {\n            synchronized(dest) {\n                //do transfer operation\n            }\n        }\n    } else if(fromHash > toHash) {\n         synchronized(dest) {\n            synchronized(from) {\n                //do transfer operation\n            }\n        }\n    } else {\n         synchronized(tieLock) { //加时赛锁\n            synchronized(from) {\n                synchronized(dest) {\n                    //do transfer operation\n                }\n            }\n        }\n    }\n}\n```\n**在协作对象之间发生的死锁**\n如果在持有锁时调用某个外部方法，那么将可能出现活跃性问题。在这个外部方法中可能会获取其他锁(这可能产生死锁)，或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。\n**开放调用(Open Call)**：如果在调用某个方法时，不需要持有锁，那么这种调用称为开放调用。\n在程序中尽量使用开放调用，与那些持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。\n\n\n**资源死锁(Resource Deadlock)**\n当多个线程互相持有彼此正在等待的资源而又不释放自己的资源时会发生资源死锁。\n线程饥饿死锁(Thread-Starvation Deadlock)\n\n**其他活跃性问题**\n\n- 饥饿：当线程由于无法访问它所需要的资源而不能继续执行时，引发饥饿最常见的资源是CPU时钟周期。Java中要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线程优先级。\n- 活锁(Livelock)：线程将不断重复执行相同的操作，而且总会失败。活锁通常发生在消息机制中，如果不能成功处理某个消息，那么消息处理机制将回滚整个事务，并将其发到队列头部，这样可能导致每次回滚，每次失败，不停重试。为了解决活锁问题，需要在重试机制中引入随机性。\n\n**死锁避免**\n\n- 确保线程在获取多个锁时采用一致的顺序\n- 在程序中始终使用开放调用\n- 使用支持定时的锁，如`Lock.tryLock()`\n\n###性能与可伸缩性\n**可伸缩性**：当增加计算资源时(如CPU、内存、存储容量或I/O带宽)，程序的吞吐量或者处理能力相应的增加。\n\n**线程开销包括**：线程之间的协调(内存同步)、线程上下文切换、线程的创建和销毁、线程的调度\n在synchronized和volatile提供的可见性保证中可能使用一些特殊指定即内存栅栏(Memory Barrier)，内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。\n\n不要过度担心非竞争同步带来的开销，这个基本非常快，并且JVM还能进行额外的优化以进一步降低或消除开销。因此，优化重点应该放在那些发生锁竞争的地方。\n在并发程序中，对可伸缩性的最主要威胁是独占方式的资源锁。\n\n非竞争同步可以完全在JVM中进行处理，而竞争的同步可能需要操作系统的介入。当在锁上发生竞争时，竞争失败的线程肯定会阻塞，JVM在实现阻塞的行为时，可以采用子旋等待(Spin-Waiting)或者通过操作系统挂起被阻塞的线程。\n\n**减少锁的竞争**\n\n- 缩小锁的范围\n- 减小锁的粒度\n - 锁分解：将一个锁分解为两个锁\n - 锁分段：把一个锁分解为多个锁(ConcurrentHashMap默认分解为16个锁)\n- 避免热点域(Hot field) ：例如引入缓存机制或对象池，这样可以提高性能，但是同时多线程环境下即可能成为热点域，往往会限制可伸缩性。对象分配操作的开销比同步的开销更低。\n- 替代独占锁：`ReadWriteLock`、原子变量\n"}