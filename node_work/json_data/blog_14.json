{"text":"###单例模式\n**意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点\n**动机**：对一些类来说，只有一个实例是很重要的。让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。\n**适用性**\n- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。\n- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。\n\n**结构**\n![Alt text](http://img.itc.cn/photo/jt8vmtaW6J4)\n\n**参与者**\n- Singleton\n    - 定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作（即一个静态成员函数）。\n    - 可能负责创建它自己的唯一实例\n\n**协作**\n客户只能通过Singleton的Instance操作访问一个Singleton的实例\n\n**效果**\n- 对唯一实例的受控访问\n- 缩小名空间，Singleton模式是对全局变量的一种改进。\n- 允许对操作和表示的精化。Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的\n- 允许可变数目的实例\n- 比类(静态类)操作更灵活(静态类必须是无状态的，Singleton可以是有状态的)\n\n###实现\nEageer Singleton：私有化构造函数，定义一个static成语并在声明时候初始化，并提供一个获取静态实例的静态方法。不会存在多线程环境下，实例创建的竞争问题，由JVM虚拟机初始化机制保障。\n\n```\npublic final class Singleton()  {\n    private static Singleton instance = new Singleton();\n    \n    private Singleton() {\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\npublic enum Singleton {\n    INSTANCE;\n}\n```\n\nLazy Singleton：用到的时候进行判断实例是否初始化，可能存在多线程并发的风险。\n\n```\npublic class Singleton()  {\n    private static Singleton instance;\n    \n    private Singleton() {\n    }\n    \n    public synchronized static Singleton getInstance() {\n        if(instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n    \n    public static Singleton getInstance() {\n        if(instance == null) {\n            synchronized(Singleton.class) {\n                instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n    \n    //extension: double checked\n    public static Singleton getInstance() {\n        if(instance == null) {\n            synchronized(Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n双重检查DCL也不能保证多线程情况下只创建一个实例，由于JVM本身可能存在指令重排序等，导致创建多个实例([参考ifeve文章](http://ifeve.com/doublecheckedlocking/))。一般建议使用饿汉方式(Eager Singleton)。JDK5以后我们可以采用enum方式来创建单例(Effective Java中推荐的方式)，和类懒加载方式性能相当，不过更简洁同样不会存在多线程竞争的问题。\n\n**Signleton的状态**\nStateful object：有状态的对象包含并维护一个内部状态，状态可以通过方法调用和发生转换。一个类的不同有状态的对象是不一样的。\nStateless object：无状态的对象在方法调用的时候，不包含任何状态，一个类的不同无状态的对象是相同的。\nSignleton可以是有状态的也可以是无状态的\n- 有状态的Singleton所有clients共享这些内部状态信息，若多线程情况下访问这些状态信息方法，需要保证线程安全。\n- 推荐使用无状态的Singleton\n\n**Singleton和继承**\nSingleton类声明如果是非final(或者构造函数声明为protected)，这样其可以拥有子类。\n- 若子类构造函数声明为public，这样Singleton就是不完整的\n- 有些场景是又要的，但是不推荐去继承Singleton\n\n###JDK中Singleton实例\n- Singleton (recognizeable by creational methods returning the same instance (usually of itself) everytime)\n- java.lang.Runtime#getRuntime()\n- java.awt.Desktop#getDesktop()\n- java.awt.Toolkit#getDefaultToolkit()\n"}