{"text":"###EnumMap源码阅读\nEnumMap是一个用于存放键值为enum类型的map，所有的键值必须来自一个单一的enum类型。EnumMap内部用数组表示效率更高。\nEnumMap维持键值的自然顺序(即枚举类型常量声明的顺序)，可以通过`keySet()`和`entrySet()`方法的集合视图来体现其顺序。\n集合视图返回的迭代器是弱一致的：遍历时候不会抛出`ConcurrentModificationException`，遍历过程中若对容器进行修改，修改产生的影响遍历过程可能可见也可能不可见。\n不允许`null`键值插入，插入空值将会抛出`NullPointerException`。测试空值是否存在或删除空值操作是允许的。\n和其他集合对象实现类似，EnumMap不保证线程安全，可以通过集合帮助类的方法进行包装，返回线程安全的容器。\n\n```JAVA\nMap<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));\n```\n\n###EnumMap实现\n类的定义，可以看到键值必须是继承Enum<K>对象的实例\n\n```JAVA\npublic class EnumMap<K extends Enum<K>, V> extends AbstractMap<K, V>\n    implements java.io.Serializable, Cloneable\n```\n\n**成员变量**\n```\nprivate final Class<K> keyType; //key对应的class对象\n// All of the values comprising K.  (Cached for performance.)\nprivate transient K[] keyUniverse; \n//Array representation of this map. \nprivate transient Object[] vals;\nprivate transient int size = 0; //map的大小\n//用非空值对象来表示null\nprivate static final Object NULL = new Object();\n```\n\n**构造方法**\n```\npublic EnumMap(Class<K> keyType) {\n    this.keyType = keyType;\n    keyUniverse = getKeyUniverse(keyType);\n    vals = new Object[keyUniverse.length];\n}\n/**\n * Returns all of the values comprising K.\n * The result is uncloned, cached, and shared by all callers.\n * 调用sun.misc.SharedSecrets类中方法返回对应枚举类的成员\n */\nprivate static <K extends Enum<K>> K[] getKeyUniverse(Class<K> keyType) {\n    return SharedSecrets.getJavaLangAccess()\n\t\t\t\t.getEnumConstantsShared(keyType);\n}\n```\n\n**put和remove方法**\n```JAVA\npublic V put(K key, V value) {\n    typeCheck(key);\n    int index = ((Enum)key).ordinal();\n    Object oldValue = vals[index];\n    vals[index] = maskNull(value);\n    if (oldValue == null)\n        size++;\n    return unmaskNull(oldValue);\n}\n//检查是否为初始化时传入的枚举类型或其子类型(? extends K)\nprivate void typeCheck(K key) {\n    Class keyClass = key.getClass();\n    if (keyClass != keyType && keyClass.getSuperclass() != keyType)\n        throw new ClassCastException(keyClass + \" != \" + keyType);\n}\nprivate Object maskNull(Object value) {\n    return (value == null ? NULL : value);\n}\nprivate V unmaskNull(Object value) {\n    return (V) (value == NULL ? null : value);\n}\npublic V remove(Object key) {\n    if (!isValidKey(key))\n        return null;\n    int index = ((Enum)key).ordinal();\n    Object oldValue = vals[index];\n    vals[index] = null;\n    if (oldValue != null)\n        size--;\n    return unmaskNull(oldValue);\n}\n```\n**get方法**\n```\npublic V get(Object key) {\n    return (isValidKey(key) ?\n            unmaskNull(vals[((Enum)key).ordinal()]) : null);\n}\nprivate boolean isValidKey(Object key) {\n    if (key == null)\n        return false;\n    // Cheaper than instanceof Enum followed by getDeclaringClass\n    Class keyClass = key.getClass();\n    return keyClass == keyType || keyClass.getSuperclass() == keyType;\n}\n```\n\n**查找方法**\n\n```JAVA\npublic boolean containsKey(Object key) {\n    return isValidKey(key) && vals[((Enum)key).ordinal()] != null;\n}\n//即使是value为null，由于内部调用maskNull所以不会有空指针异常\nprivate boolean containsMapping(Object key, Object value) {\n    return isValidKey(key) &&\n        maskNull(value).equals(vals[((Enum)key).ordinal()]);\n}\npublic boolean containsValue(Object value) {\n    value = maskNull(value);\n    for (Object val : vals)\n        if (value.equals(val))\n            return true;\n    return false;\n}\n```\n\n###集合视图\n和`HashMap`类似，提供`keySet()`、`values()`、`entrySet()`方法，返回键集合、值集合、键值对集合视图。下面介绍下键集合视图，由于这些视图是无状态的，没必要每次都重新创建。ketSet方法返回一个内部类EnumMap$KeySet实例。\n```\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    if (ks != null)\n        return ks;\n    else\n        return keySet = new KeySet();\n}\nprivate class KeySet extends AbstractSet<K> {\n    public Iterator<K> iterator() {\n        return new KeyIterator();\n    }\n    public int size() {\n        return size;\n    }\n    public boolean contains(Object o) {\n        return containsKey(o);\n    }\n    public boolean remove(Object o) {\n        int oldSize = size;\n        EnumMap.this.remove(o);\n        return size != oldSize;\n    }\n    public void clear() {\n        EnumMap.this.clear();\n    }\n}\n```\n**视图的迭代器**\nKeySet的迭代器返回内部类`KeyIterator`实例，其继承自`EnumMapIterator`,实际`EnumMapIterator`实现了整个Entry的迭代，根据不同视图，next方法返回键、值或键值对。内部没有检查遍历过程是否修改，所以不会抛异常。     \n```JAVA\nprivate class KeyIterator extends EnumMapIterator<K> {\n    public K next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        lastReturnedIndex = index++;\n        return keyUniverse[lastReturnedIndex];\n    }\n}\n\nprivate class ValueIterator extends EnumMapIterator<V> {\n    public V next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        lastReturnedIndex = index++;\n        return unmaskNull(vals[lastReturnedIndex]);\n    }\n}\n\nprivate abstract class EnumMapIterator<T> implements Iterator<T> {\n    // Lower bound on index of next element to return\n    int index = 0;\n    // Index of last returned element, or -1 if none\n    int lastReturnedIndex = -1;\n    \n    public boolean hasNext() {\n        while (index < vals.length && vals[index] == null)\n            index++;\n        return index != vals.length;\n    }\n\n    public void remove() {\n        checkLastReturnedIndex();\n        if (vals[lastReturnedIndex] != null) {\n            vals[lastReturnedIndex] = null;\n            size--;\n        }\n        lastReturnedIndex = -1;\n    }\n\n    private void checkLastReturnedIndex() {\n        if (lastReturnedIndex < 0)\n            throw new IllegalStateException();\n    }\n}\n```\n\n###总结\n1. `EnumMap`的键值必须是Enum类型，而且put的时候只能是初始化时指定的Enum或者其子类型。同时不支持键值为null。\n2. `EnumMap`初始化会创建存放key和value的两个数组，大小为Enum类型中成员数量，同时会缓存所有Enum类型到key数组。\n3. `EnumMap`迭代保持键值的自然顺序(即枚举类型常量声明的顺序)，其实通过Enum内部`ordinal()`方法实现，vals数组每次插入元素都放插入到key值对应的`ordinal()`返回的位置。"}