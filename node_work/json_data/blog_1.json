{"text":"###Collection类结构###\n`Collection`接口下有三个子接口类型：`List`、`Set`、`Queue`\n\n![java collection](http://img.blog.csdn.net/20141114124914937)\n\n###LinkedList接口###\n`LinkedList`实现了`List`和`Deque`两种类型的接口,`List`接口就是顺序表，在上一节`ArrayList`中有介绍。\n\n`Deque`是\"double ended queue\"缩写，代表一个线性的集合支持在两端插入和删除元素操作。`Deque`接口定义了通过两端头和尾访问元素的方法，包括插入、删除、检查等。每个方法存在两种形式：抛出异常如果失败、返回一个特定值(null或false等)。方法具体描述如下:\n\n|   |   First Element| First Element  |  Last Element | Last Element  |\n|---|---|---|---|---|\n|  Type |  Throws exception |  Special value |  Throws exception |Special value   |\n| Insert  | addFirst(e)  | offerFirst(e)  | addLast(e)  | offerLast(e)   |\n| Remove  | removeFirst()  | pollFirst()  | removeLast()  |pollLast()   |\n| Examine  | getFirst()  | peekFirst()  | getLast()  | peekLast()   |\n\n`Deque`扩展了`Queue`接口，因此看以看做是个`FIFO`先进先出队列，元素是在队列尾部添加，头部删除。`Queue`和`Deque`中方法对应关系如下：\n\n| Queue Method  |  Equivalent Deque Method |\n|---|---|\n| add(e)  | addLast(e)  |\n| offer(e) | offerLast(e)  |\n| remove()  | removeFirst()   |\n| poll()  | pollFirst()  |\n| element()  | getFirst()  |\n| peek()  | peekFirst()  |\n\n`Deque`也可以当做`LlIFO`后进先出的栈，类似于集合类中的`Stack`。当用于栈时，元素从头部添加和删除，对应方法如下：\n\n| Stack Method  |  Equivalent Deque Method |\n|---|---|\n| push(e)  | addFirst(e)  |\n| pop() | removeFirst()  |\n| peek()  | peekFirst()   |\n\n###LinkedList实现###\n\n**类的定义**\n```\npublic class LinkedList<E>\n\textends AbstractSequentialList<E>\n\timplements List<E>, Deque<E>, Cloneable, java.io.Serializable\n```\n\n**成员**\n```\n private transient Entry<E> header = new Entry<E>(null, null, null);\n private transient int size = 0;\n```\n`LinkedList`采用双向链表，定义了一个头结点，`Entry`代表链表一个节点，header不包含有意义值，即使链表为空也有一个头结点，实际是一个带头节点的双向链表。\n```\n private static class Entry<E> {\n\tE element;\n\tEntry<E> next;\n\tEntry<E> previous;\n}\n```\n**方法**\n\n构造方法负责初始化头节点的next和previouse引用，都指向自己本身。\n```\npublic LinkedList() {\n\theader.next = header.previous = header;\n}\n```\nadd方法，addBefore(e,entry)实现在entry前面插入元素\n```\npublic boolean add(E e) {\n\taddBefore(e, header);  //尾部添加\n\treturn true;\n}\nprivate Entry<E> addBefore(E e, Entry<E> entry) {\n\tEntry<E> newEntry = new Entry<E>(e, entry, entry.previous); \n\t//newEntry->next=entry,newEntry->previous=entry->previous\n\tnewEntry.previous.next = newEntry; //entry->previous->next = newEntry\n\tnewEntry.next.previous = newEntry; //entry->previous = newEntry\n\tsize++;\n\tmodCount++;\n\treturn newEntry;\n}\npublic void add(int index, E element) {\n    addBefore(element, (index==size ? header : entry(index)));\n}\nprivate Entry<E> entry(int index) {\n    if (index < 0 || index >= size)\n        throw new IndexOutOfBoundsException(\"Index: \"+index+\n                                            \", Size: \"+size);\n    Entry<E> e = header;\n    if (index < (size >> 1)) { //前半部分\n        for (int i = 0; i <= index; i++)\n            e = e.next;\n    } else { \n        for (int i = size; i > index; i--)\n            e = e.previous;\n    }\n    return e;\n}\n```\t\nget方法\n```\npublic E get(int index) {\n\treturn entry(index).element;\n}\npublic E getFirst() {\n\tif (size==0)\n    \tthrow new NoSuchElementException();\n\treturn header.next.element;\n}\n```\n其他操作如remove等，不一一介绍，主要是涉及链表操作，注意该链表是带一个头结点。\n\n###迭代器的实现###\n\n支持单向和双向迭代器，默认都是调用内部类`LinkedList$ListItr`类实现\n\n\n**类定义**\n```\nprivate class ListItr implements ListIterator<E> {\n\tprivate Entry<E> lastReturned = header; \n\tprivate Entry<E> next; //当前遍历位置\n\tprivate int nextIndex; //当前index\n\tprivate int expectedModCount = modCount;\n}\n```\n**方法**\n```\nListItr(int index) {\n    if (index < 0 || index > size)\n\tthrow new IndexOutOfBoundsException(\"Index: \"+index+\n\t\t\t\t\t    \", Size: \"+size);\n    if (index < (size >> 1)) {\n\t\tnext = header.next;\n\tfor (nextIndex=0; nextIndex<index; nextIndex++)\n\t    next = next.next;\n    } else {\n\t\tnext = header;\n\tfor (nextIndex=size; nextIndex>index; nextIndex--)\n\t    next = next.previous;\n    }\n}\n\npublic boolean hasNext() {\n    return nextIndex != size;\n}\n\npublic E next() {\n    checkForComodification();\n    if (nextIndex == size)\n\t\tthrow new NoSuchElementException();\n    lastReturned = next;\n    next = next.next;\n    nextIndex++;\n    return lastReturned.element;\n}\n\npublic boolean hasPrevious() {\n    return nextIndex != 0;\n}\n\npublic E previous() {\n    if (nextIndex == 0)\n\t\tthrow new NoSuchElementException();\n    lastReturned = next = next.previous;\n    nextIndex--;\n    checkForComodification();\n    return lastReturned.element;\n}\n```\n和`ArrayList`中的迭代器实现类似，通过内部类直接访问外部类的成员和方法实现遍历操作，不过由于采用链表方式，多了一个next指向链表遍历位置的引用元素。\n\n###总结###\n\n1. `LinkedList`实现了`List`和`Deque`接口，其中`Deque`是一个双端队列，可以在头部和尾部两端添加和删除元素，因此`LinkedList`既可以当作先进先出的队列，也可以当作后进先出的栈。\n2. `LinkedList`采用双向链表方式实现，因此插入、删除元素效率比较高，但不支持随机访问。\n3. 多线程环境下`LinkedList`不能保证线程安全，因此对其结构修改的操作应当程序员来保证线程安全，其迭代器支持`fail-fast`,迭代过程中试图发现是否发生修改，若修改了容器则抛出`ConcurrentModificationException`。\n"}