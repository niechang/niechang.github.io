{"text":"###客户端\nRedis服务端使用单线程单进程的方式处理命令请求，并与多个客户端进行通信。每个客户端对应一个`redisClient`结构实例，所有客户端以链表方式保存在`redisServer`中。\n\n**客户端属性**\n\n客户端属性分为通用属性和特定功能相关属性，下面主要介绍通用属性\n```C\ntypdef struct redisClient {\n    int fd;//套接字描述符\n    robj name;//名字\n    int flags;//标记\n    sds querybuf;//输入缓冲区\n    robj **argv; //命令参数\n    int     argc;//命令参数个数\n    struct redisCommand *cmd; //客户端要执行命令的实现函数\n    char buf[REDIS_REPLY_CHUNK_BYTES]; //固定大小输出缓冲区\n    int     bufpos;\n    list*     reply; //可变大小输出缓冲区\n    int     authenticated;//身份验证\n    time_t     ctime;//创建时间\n    time_t     lastinteraction; //最后一次互动时间\n    time_t     obuf_soft_limit_reached_time;//输出缓冲区第一次到达软性限制时间  \n}\n```\n\n- 套接字描述符：客户端状态的fd属性记录了客户端正在使用的套接字。当为伪客户端时fd=-1，如请求源于AOF文件或lua脚本；普通客户端为大于-1的整数。通过`ClIENT list`命令查看当前所有客户端信息。\n- 名字，默认情况下客户端没有名字，可以通过`CLIENT setname ..`来设置\n- 标志，flags属性用于记录客户端的角色以及客户端目前所处的状态\n- 输入缓冲区：用于保存客户端发送的命令请求，其可以不断扩容但不能超过1GB\n- 命令与命令参数：argv属性是一个数组，每一个项是一个字符串，其中argv[0]为要执行的命令，argc为数组的长度。服务端根据argv[0]的值在命令表中查找所对应的命令实现函数，命令表是一个<SDS, redisCommand>的字典结构。\n- 输出缓冲区：执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端有两个输出缓冲区\n    - 固定大小缓冲区：用于保存长度比较小的回复，默认16K\n    - 可变大小缓冲区：保存比长度较大的回复\n- 身份验证，`authenticated`属性用于记录客户端是否通过了身份验证。如果其值为0表示未通过验证；如果为1表示已经通过身份验证。未通过验证时，除了AUTH命令之外客户端其他命令都会被服务器拒绝执行。该属性仅在服务器启动了身份验证功能时使用\n- 时间：创建时间、最后一次与服务器互动时间、输出缓冲区第一次到达软性限制时间  \n\n**客户端创建与关闭**\n\n普通客户端通过网络连接方式，客户端调用connect函数连接到服务端时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态。\n\n关闭客户端的原因：\n\n- 客户端进程被退出或杀死\n- 客户端向服务器发送带有不符合协议格式的命令请求\n- 客户端称为CLIENT KILL命令的目标\n- 用户为服务器设置了timeout属性，当客户端的空转时间超过timeout时\n- 客户端发送的命令请求的大小超过了输入缓冲区限制(默认1GB)\n- 发送给客户端的命令回复的大小超过了输出缓冲区的限制大小\n    - 硬性限制：输出缓冲区大小超过硬性限制阈值，客户端立即关闭\n    - 软性限制：输出缓冲区超过软性限制，但没有超过硬性限制，通过客户端的`obuf_soft_limit_reached_time`记录达到软性限制的时间，之后服务器继续监视客户端，如果在一直超过软性限制并且持续时间超过服务器设置的时间，服务器将会关闭客户端，否则不会关闭客户端。`client-output-buffer-limit <class> <hard limit> <soft limt> <soft seconds>`设置硬性和软性限制大小。\n\n**Lua脚本伪客户端**：服务器在初始化时负责执行Lua脚本中包含的Redis命令的伪客户端，lua_client伪客户端在服务器执行周期中一直存在。\n\n**AOF文件伪客户端**：服务器在载入AOF文件时创建，载入完成后关闭这个伪客户端。\n\n\n###服务器\nRedis服务器负责与多个客户端建立网络连接，处理客户端请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。\n\n**命令请求的执行过程**\n\n1. 客户端发送命令请求\n2. 读取命令请求，将命令请求保存到客户端状态的输入缓冲区\n3. 命令执行器\n    - 查找命令\n    - 执行预备操作\n    - 调用命令的实现函数：`client->cmd->proc(client)`命令调用后会产生相应的回复，这些回复会被保存在客户端状态的输出缓冲区中\n    - 执行后续工作\n4. 将命令回复发送给客户端\n5. 客户端接收并打印命令回复\n\n**serverCron函数**\n\nRedis中serverCron函数每隔100毫秒执行一次，负责管理服务器资源，并保持服务器自身的良好运转\n```C\nstruct redisServer {\n    time_t     unixtime; //保存秒级精度的系统当前UNIX时间戳\n    long long     mstime; //保存了毫秒级精度的系统当前UNIX时间戳\n    unsigned     lrulock:22;//默认每10秒更新一次的时钟缓存，用于计算键的空转时长\n    size_t     stat_peak_memory;//内存峰值大小\n    int     shutdown_asap; //关闭服务器标识，1关闭，0不做动作\n    int     aof_rewrite_scheduled; //如果为1，那么表示有BGREWRITEAOF命令被延迟了\n    pid_t     rdb_child_pid;//BGSAVE命令的子进程ID，没有则为-1\n    pid_t     aof_child_pid;//BGREWRITEAOF命令的子进程ID，没有则为-1      \n    int     cronloops;//serverCron函数执行次数\n}\n```\n\n- 更新服务器时间缓存，每次获取系统的当前时间需要执行一次系统调用，为了减少系统调用次数缓存服务器时间\n- 更新LRU时钟，lrulock保存了服务器的LRU时钟，每个Redis对象有个lru属性，该键对应空转时长等于`lrulock - lru`\n- 更新每秒执行命令的次数：serverCron中的trackOperationsPerSecond函数会以100毫秒一次的频率执行，以抽样的方式，估算并记录服务器最近一秒钟处理的命令请求数量，可以通过`INFO status`命令查看。\n- 更新服务器内存峰值记录：`stat_peak_memory`属性记录了服务器的内存峰值大小，通过`INFO memory`查看\n- 处理SIGTERM信号：服务器启动时将`SIGTERM`信号关联处理器`sigtermHandler`函数\n- 管理客户端资源：如果客户端与服务器之间连接超时，那么释放这个客户端；如果客户端上一次执行命令请求之后，输入缓冲区的大小超过一定长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个输入缓冲区\n- 管理数据库资源：调用`databasesCron`函数对服务器中的部分数据库进行检查，删除其中过期键，需要时对字典进行收缩操作\n- 执行被延迟的BGREWRITEAOF：在服务器执行BGSAVE期间，如果客户端发起BGREWRITEAOF命令，那么该命令将会被延迟到BGSAVE命令执行之后\n- 检查持久化操作的运行状态\n- 将AOF缓冲区中的内容写入AOF文件\n- 关闭异步客户端\n- 增加cronloops计数器的值，cronloops属性记录了serverCron的执行次数\n\n**初始化服务器**\n\n1. 初始化服务器状态结构\n2. 载入服务器配置\n3. 初始化服务器数据结构\n4. 还原数据库状态：如果启用AOF持久化功能，使用AOF文件还原；否则使用RDB文件还原\n5. 执行事件循环\n"}