{"text":"###ThreadLocal\nThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。归纳了两点\n\n- 每个线程中都有一个自己的`ThreadLocalMap`类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 \n- 将一个共用的`ThreadLocal`静态实例作为key，将不同对象的引用保存到不同线程的`ThreadLocalMap`中，然后在线程执行的各处通过这个静态`ThreadLocal`实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。这就是为什么get()方法不需要指定key值得原因。\n\n```\npublic class Thread {\n    /* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}\n\npublic class ThreadLocal<T> { \n    private final int threadLocalHashCode = nextHashCode();\n    private static AtomicInteger nextHashCode = new AtomicInteger();   \n    private static final int HASH_INCREMENT = 0x61c88647; \n    \n    private static int nextHashCode() {\n\t    return nextHashCode.getAndAdd(HASH_INCREMENT); \n    }\n    \n    void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n    \n    private T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\n    \n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n    \n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n    \n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n    \n    //内部类，类似WeakHashMap的实现，内部采用数组实现，采用线性探测策略\n    static class ThreadLocalMap {\n        private Entry[] table;\n        \n        private int size = 0;\n        \n        ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {\n            table = new Entry[INITIAL_CAPACITY];\n            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n            table[i] = new Entry(firstKey, firstValue);\n            size = 1;\n            setThreshold(INITIAL_CAPACITY);\n        }\n        \n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n     }\n}\n```\n"}