{"text":"###45. 将局部变量作用域最小化\n- 在第一次使用局部变量的地方进行声明\n- 几乎每个局部变量的声明都应该包含一个初始化表达式\n- 如果在循环终止后不再需要循环变量，for循环就优先于while循环\n\n###46. for-each循环优先于传统的for循环\n- for-each循环不仅可以遍历集合和数组，还可以遍历任何实现Iterable接口的对象，并不会有性能损耗\n- 无法使用for-each情况\n    - 过滤：遍历集合过程，并删除指定元素\n    - 转换：遍历集合或数组，并取代它部分或全部的元素值\n    - 平行迭代：如果需要并行的遍历多个集合，就需要显示的控制迭代器或索引变量\n\n###47. 了解和使用类库\n\n###48. 如果需要精确的答案，请避免使用float和double\n- float和double类型主要是用于科学计算和工程计算，它们执行二进制浮点运算\n- float和double尤其不适合用于货币计算\n- 如果数值范围不超过9位十进制数可以使用int，如果数值范围不超过18位十进制数可以使用long，否则必须使用BigDecimal\n\n###49. 基本类型优先于装箱基本类型\n```Java\nComparator<Integer> naturalOrder = new Comparator<Integer>() {\n    public int compare(Integer first, Integer second) {\n          return first < second ? -1 : (first == second ? 0 : 1); //first == second存在问题，引用类型\n     }\n};\n```\n- 对装箱基本类型使用==操作符几乎总是错误的\n- 在一项操作中混合基本类型和装箱基本类型时，装箱基本类型就会自动拆箱\n- 作为集合中的元素、键、值就必须使用装箱基本类型\n\n###50. 如果其他类型更适合，则尽量避免使用字符串\n- 字符串不适合代替其他值类型\n- 字符串不适合代替枚举类型\n- 字符串不适合代理能力表\n\n###51. 当心字符串连接的性能\n当有大量字符串拼接操作时，考虑使用`StringBuilder`\n\n###52. 通过接口引用对象\n- 如果有合适的接口类存在，那么对于参数、返回值、变量和域来说，就都应该优先使用接口类型进行声明\n- 如果养成了用接口作为类型的习惯，你的程序将会更加灵活\n\n###53. 接口优先于反射机制\n反射机制提供了通过程序来访问关于已加载类的信息，反射缺陷\n\n- 丧失了编译时类型检查的好处\n- 执行反射访问所需要的代码非常笨拙和冗长\n- 性能损失\n\n###54. 谨慎的使用本地方法\n本地方法(native method)的三种用途：\n\n- 提供了访问特定于平台的机制的能力\n- 提供了访问遗留代码库的能力\n- 可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能\n\n###55. 谨慎的进行优化\n\n- 不要因为性能而牺牲合理的解构，要努力编写好的程序而不是快的程序\n- 努力避免那些限制性能的设计决策\n\n###56. 遵守普遍的命名惯例\n"}