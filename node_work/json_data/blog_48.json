{"text":"###1. 考虑用静态工厂方法代替构造函数\n静态工厂方法优势\n\n- 静态工厂方法一大优势在于有名称。\n- 不必每次创建的时候都创建一个新对象。\n- 静态工厂方法可以返回类型的任何子类型的对象(如`EnumSet.of`方法返回实例包括`RegularEnumSet`或`JumboEnumSet`)\n- 在创建参数化类型实例的时候，它们使代码变得更加简洁\n\n静态工厂方法劣势\n\n- 类如果不含公有或者受保护的构造器，就不能被子类化\n- 静态工厂方法与类的其他静态方法没有区别，常用名字包括：`valueOf`、`of`、`newInstance`、`newType`\n\n###2. 遇到多个构造器参数时考虑用构造器\n静态方法和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。\n当有许多参数时，重叠构造器模式使得客户端代码会很难编写和难以阅读。\n另一种替代方法使用JavaBean，这样会在构造过程中JavaBean可能处于不一致的状态，JavaBean模式阻止了类做成不可变的可能。\nBuilder模式可以保证构造器模式的安全性，也能保证JavaBean模式的可读性。\n\n###3. 用私有构造器或者枚举类型强化Singleton属性\n单例模式可以通过声明一个该类型的私有成员，并将构造函数私有化，然后提供一个静态方法返回该实例，此外若该类声明为可序列化，还需要实现`readResolve`方法保证反序列化的时候只返回一个实例\n单元素的枚举类型已经成为实现Singleton的最佳方法，无偿提供序列化机制\n\n###4. 通过私有构造器强化不可实例化的能力\n工具类(utility class)不希望被实例化，可以提供一个私有构造函数来实现。\n\n###5. 避免创建不必要的对象\n`String s=new String(\"stringette\")`是很糟糕的代码\n对于提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。\n优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。\n\n###6. 消除过期的对象引用\n过期引用指永远不会再被解除的引用，这种过期对象引起的内存泄露为“无意识的对象保持”。\n```\npublic Object pop() {\n    if(size == 0)\n          throw new EmptyStackException();\n    Object result = elements[--size];\n    elements[size] = null;//清空对象引用，避免无意识的对象保持\n    return result;\n}\n```\n只要是类自己管理内存，程序员就应该警惕内存泄露问题。内存泄露另一个常见源是缓存。\n只有当所要缓存项的生命周期是由该键值的外部引用而不是由值决定时，`WeakHashMap`才有用处。\n内存引用另外一个来源是监听器和其他回调。\n\n###7. 避免使用终结方法\n终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。\nJava语言规范不仅不能保证finalize方法被及时执行，而且根本就不保证它会执行，不应该依赖终结方法来更新重要的持久状态。此外终结方法会带来严重性能损失。\n显示的终止方法通常与try-finally结构结合起来使用，以确保及时终止。"}