{"text":"###ArrayList实现###\n**继承关系**\n```\njava.lang.Object\n    - java.util.AbstractCollection<E>\n        - java.util.AbstractList<E>\n            - java.util.ArrayList<E>\n```\n \n**实现接口**\n\n```\nSerializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess\n```\n\n**关键属性**\n\n```\nprivate transient Object[] elementData;    \n//transient修饰不会序列化，但实现了Serializable接口，重写了readObject和writeObject方法只序列化实际大小\nprivate int size;    //实际大小\n```\n\n**常见方法**\n\n```\npublic boolean add(E e) {\n\tensureCapacity(size + 1);  // Increments modCount!!\n\telementData[size++] = e;\n\treturn true;\n}\n\npublic void add(int index, E element) {  \n\tif (index > size || index < 0)  \n\t    throw new IndexOutOfBoundsException(  \n\t    \"Index: \"+index+\", Size: \"+size);  \n\tensureCapacity(size+1);  // Increments modCount!!  \n\tSystem.arraycopy(elementData, index, elementData, index + 1,  \n\t         size - index); //elementData[index,size) --> elementData[index+1,size+1)  \n\telementData[index] = element;  \n\tsize++;  \n}  \n```\n\n`ensureCapacity`扩容方法：开始前有对modCount修改操作，实现`fast-fail`迭代\n\n```\npublic void ensureCapacity(int minCapacity) {  \n    modCount++;  \n    int oldCapacity = elementData.length;  \n    if (minCapacity > oldCapacity) {  \n        Object oldData[] = elementData;  \n        int newCapacity = (oldCapacity * 3)/2 + 1; //0.5倍扩容策略  \n            if (newCapacity < minCapacity)  \n        newCapacity = minCapacity;  \n            // minCapacity is usually close to size, so this is a win:  \n            elementData = Arrays.copyOf(elementData, newCapacity);  \n    }  \n}  \n```\n\nremove方法，移动index+1及其后面元素，并将最后一个元素设置为null，帮助GC回收\n\n```\npublic E remove(int index) {  \n\tRangeCheck(index);  \n\tmodCount++;  \n\tE oldValue = (E) elementData[index];  \n\tint numMoved = size - index - 1;  \n\tif (numMoved > 0)  \n\t    System.arraycopy(elementData, index+1, elementData, index,  \n\t             numMoved); //elementData[index+1,size) -->elementData[index,size-1)  \n\t\telementData[--size] = null; // Let gc do its work  \n\treturn oldValue;  \n}  \n\npublic boolean remove(Object o) {  \n    if (o == null) {  \n        for (int index = 0; index < size; index++)  \n        if (elementData[index] == null) {  \n            fastRemove(index);  \n            return true;  \n        }  \n    } else {  \n        for (int index = 0; index < size; index++)  \n        if (o.equals(elementData[index])) {  \n            fastRemove(index);  \n            return true;  \n        }  \n    }  \n\treturn false;  \n}\n```\n\nfastRemove是私有方法没有返回old value\n\n```\nprivate void fastRemove(int index) {  \n    modCount++;  \n    int numMoved = size - index - 1;  \n    if (numMoved > 0)  \n        System.arraycopy(elementData, index+1, elementData, index,  \n                         numMoved);  \n    elementData[--size] = null; // Let gc do its work  \n}  \n```\n\n重写readObject和writeObject进行序列化和反序列化，保证只会序列化实际大小的数组避免空间浪费，可以看到writeObject的时候有fast fail判断\n\n```\nprivate void readObject(java.io.ObjectInputStream s)  \n        throws java.io.IOException, ClassNotFoundException {  \n    // Read in size, and any hidden stuff  \n    s.defaultReadObject();  \n    // Read in array length and allocate array  \n    int arrayLength = s.readInt();  \n    Object[] a = elementData = new Object[arrayLength];  \n    // Read in all elements in the proper order.  \n    for (int i=0; i<size; i++)  \n        a[i] = s.readObject();  \n}  \n\nprivate void writeObject(java.io.ObjectOutputStream s)  \n   throws java.io.IOException{  \n\t// Write out element count, and any hidden stuff  \n\tint expectedModCount = modCount;  \n\ts.defaultWriteObject();  \n    // Write out array length  \n    s.writeInt(elementData.length);  \n\t// Write out all elements in the proper order.  \n\tfor (int i=0; i<size; i++)  \n       s.writeObject(elementData[i]);  \n\tif (modCount != expectedModCount) {  \n       throw new ConcurrentModificationException();  \n    }  \n}\n```\n\n###迭代器实现###\n\n`ArrayList`支持两种迭代器：`Iterator`和`ListIterator`(双向迭代)，实现在`AbstractList`中Iterator通过内部类AbstractList$Itr实现\n\n**Itr类定义**\n\n```\nprivate class Itr implements Iterator<E>\n```\n\n**属性包括**\n\n```\nint cursor = 0;   //当前遍历的下标\nint lastRet = -1; //最近调用next或previous返回的下标，当调用自身remove方法删除元素后，重置为-1\nint expectedModCount = modCount;  //用于检测遍历过程中并发修改\n```\n\n**重要方法**\n\nhasnext和next方法\n\n```\npublic boolean hasNext() {  \n    return cursor != size();  \n}  \npublic E next() {  \n   checkForComodification();  \n   try {  \n        E next = get(cursor);  \n        lastRet = cursor++;  \n        return next;  \n   } catch (IndexOutOfBoundsException e) {  \n        checkForComodification();  \n        throw new NoSuchElementException();  \n   }  \n}  \n```\n\nremove方法\n\n```\t\npublic void remove() {  \n    if (lastRet == -1)  \n    \tthrow new IllegalStateException();  \n        checkForComodification();  \n    try {  \n   \t\tAbstractList.this.remove(lastRet);  \n    if (lastRet < cursor)  \n        cursor--;  \n    \tlastRet = -1;  \n    \texpectedModCount = modCount;  \n    } catch (IndexOutOfBoundsException e) {  \n    \tthrow new ConcurrentModificationException();  \n    }  \n}  \n```\n\n- next和remove方法前都需要调用checkForComodification检验容器是否被修改，若被修改则抛出ConcurrentModificationException\n- 调用迭代器自身remove方法不会引起ConcurrentModificationException，这是因为删除元素以后，expectedModCount被重新设置了(expectedModCount = modCount)\n- 可以看到remove方法执行完一次删除以后，将lastRet设置为-1，下次接着调用就会抛异常。\n\n`ListIterator`通过内部类ListItr来实现，其继承了单向迭代器Itr并实现双向迭代器接口`ListIterator`\n\n**ListItr类定义**\n\n```\nprivate class ListItr extends Itr implements ListIterator<E>\n```\n\n支持指定cursor位置构造\n\n```\nListItr(int index) {  \n  cursor = index;  \n}  \n```\n\nprevious和next方法设置lastRet不同，next方法是cursor未加1之前的值，而previous是cursor减1以后的值\n\n```\npublic boolean hasPrevious() {  \n    return cursor != 0;  \n}  \npublic E previous() {  \n    checkForComodification();  \n    try {  \n        int i = cursor - 1;  \n        E previous = get(i);  \n        lastRet = cursor = i;  \n        return previous;  \n    } catch (IndexOutOfBoundsException e) {  \n        checkForComodification();  \n        throw new NoSuchElementException();  \n    }  \n}  \n```\n\nset方法是在lastRet处修改该元素的值，向前遍历一次previous则为cursor-1，向后遍历一次则为cursor\n\n```\npublic void set(E e) {  \n    if (lastRet == -1)  \n\t\tthrow new IllegalStateException();  \n    checkForComodification();  \n    try {  \n    \tAbstractList.this.set(lastRet, e);  \n    \texpectedModCount = modCount;  \n    } catch (IndexOutOfBoundsException ex) {  \n    \tthrow new ConcurrentModificationException();  \n    }  \n}\n```\n\nadd方法在当前cursor位置添加，并将cusor加1\n\n```\npublic void add(E e) {  \n    checkForComodification();  \n    try {  \n        AbstractList.this.add(cursor++, e);  \n        lastRet = -1;  \n        expectedModCount = modCount;  \n    } catch (IndexOutOfBoundsException ex) {  \n        throw new ConcurrentModificationException();  \n    }  \n} \n```\n\n###总结###\n1. `ArrayList`内部通过数组方式实现，采用加倍策略而非指定常量扩容，指定位置添加采用平摊分析复杂度为O(1)\n2. `ArrayList`中数组声明为`transient`不会序列化，重写了`readObject`和`writeObject`进行反序列化和序列化，保证只序列化有效大小的数组元素。\n3. 迭代器支持`fast-fail`，当迭代过程中检测到容器结构发生变化添加或删除元素时，会抛出`ConcurrentModificationException`，通过内部modCount实现。调用迭代器自身remove方法和双向迭代器中add和set方法不会引起并发修改异常。\n4. 迭代器中remove和set方法需要调用next或previous内部lastRet成员设置为有效索引才可以，并且调用完remove方法以后lastRet又重新设置为-1，不能直接反复调用。"}