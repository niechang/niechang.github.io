{"text":"###8. 覆盖equals方法时请遵守通用约定\nequals方法实现以下等价关系：\n\n- 自反性：x.equals(x) == true\n- 对称性：x.equals(y) == true则y.equals(x) == true\n- 传递性\n- 一致性\n- 对于任何非null的引用值，x.equals(null) == false\n\n高质量equals方法几点建议：\n\n- 使用==操作符检查\"参数是否为这个对象的引用\"\n- 使用instanceof操作符检查参数是否为正确类型\n- 把参数转换为正确类型\n- 对于该类对象的关键域，检查参数中的域是否与对象中对应的域匹配\n- 不要将equals声明中Object对象替换为其他的类型\n\n###9. 覆盖equals时总是覆盖hashCode\n\nObject规范\n\n- 在应用程序的执行期间，只要对象的equals方法的比较操作用到的信息没有被修改，那么同一个对象调用多次，hashCode方法都必须始终返回相同的整数\n- 若两个对象根据equals(Object)返回比较是相等的，则两个对象hashCode值也相同\n- 若两个对象equals(Object)返回是不相等，则任意两个对象的hashCode方法不一定要相等\n\n不要试图从散列码中排除一个对象的关键部分来提高性能\n\n###10. 始终覆盖toString\ntoString方法返回对象中包含的所有值得关注的信息；无论是否指定格式，都应该在文档中明确声明你的意图\n\n###11. 谨慎的覆盖clone方法\nCloneable接口目的是作为对象的mixin接口，表面对象允许clone。clone一般需要满足下面含义\n```JAVA\nx.clone() != x\nx.clone().getClass() == x.getClass()\nx.clone().equals(x)\n```\n实际上clone方法是另一个构造器，必须确保它不会伤害到原始对象，并确保正确的创建克隆对象中的约束条件。一般对象中有数组或集合元素，需要考虑实现深度拷贝。\n另一种实现拷贝的方法是提供一个拷贝构造器或拷贝工厂。\n\n###12. 考虑实现Comparable接口\nJava平台中所有值类(value class)都实现了Comparable接口。\ncompareTo方法将这个对象与指定的对象进行比较，当该对象小于、等于或大于指定对象时，分别返回负整数、零、正整数。\n"}