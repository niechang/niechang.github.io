{"text":"###LinkedHashMap###\n\n`LinkedHashMap`内部采用了散列表和链表实现`Map`接口，并可以保证迭代的顺序，和`HashMap`不同，其内部维护一个指向所有元素的双向链表，其决定了遍历的顺序，通常是元素插入的顺序进行迭代，不过元素重新插入顺序不会受到影响。\n`LinkedHashMap`提供一个特殊的构造函数，实现了每次迭代返回最近使用的元素，这个特性可以用于构建LRU缓存。\n此外`removeEldestEntry(Map.Entry)`方法可以被子类覆盖用于判断在添加元素的时候什么时候可以删除元素。\n`LinkedHashMap`性能同样受到初始容量和装填因子的影响，对于基本操作(add,contains,remove)在常数时间内，其性能比`HashMap`稍微低，由于需要额外代价维护链表；不过其遍历性能为O(size)高于`HashMap`O(capacity)。\n\n###LinkedHashMap实现###\n\n**类定义**\n直接继承了`HashMap`类\n```\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\n```\t    \n**成员**\n```\t\nprivate transient Entry<K,V> header; //用于遍历的双向链表表头\n\n/**\n * The iteration ordering method for this linked hash map:\n * true: for access-order, false: for insertion-order\n */\nprivate final boolean accessOrder;\n```\n\n`Entry`内部类继承了`HashMap.Entry<K,V>`类，增加了两个指针before和after用于维护遍历顺序，实际上`Entry`有三个指针父类本身有个next指针用于当发生元素冲突时指向的下一个元素。由此可以看出用于遍历的双向链表直接加在`Entry`上面，这样有效节约了空间，实际只比`HashMap`多了2*size个引用+1个头结点空间消耗。before和after这两个引用在外部类调用put或remove时，调用其相关方法进行维护(recordAccess和recordRemoval等)。\n```\t\n private static class Entry<K,V> extends HashMap.Entry<K,V> {\n\tEntry<K,V> before, after;\n\t\n\tEntry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n        super(hash, key, value, next);\n    }\n\t\n\tprivate void remove() {\n        before.after = after;\n        after.before = before;\n    }\n\t//existingEntry之前添加当前节点\n\tprivate void addBefore(Entry<K,V> existingEntry) {\n        after  = existingEntry;\n        before = existingEntry.before;\n        before.after = this;\n        after.before = this;\n    }\n\t//由父类HashMap的put方法调用，若是acessOrder，则添加到双向链表的头结点后面；本身get方法也会触发调用\n\tvoid recordAccess(HashMap<K,V> m) {\n        LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n        if (lm.accessOrder) {\n            lm.modCount++;\n            remove();\n            addBefore(lm.header);\n        }\n    }\n\t//有元素删除时，调用该类\n\tvoid recordRemoval(HashMap<K,V> m) {\n        remove();\n    }\n }\n```\nput方法是继承自父类`HashMap`，重写了当需要添加元素时候调用的addEntry方法，同样是在对应桶的链表头结点后面添加，添加完以后不是直接进行resize判断，而是判断是否要删除旧的元素，这个方法默认方法false，用户可以重写这个方法用于确定缓存的淘汰机制。\n```\t\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    createEntry(hash, key, value, bucketIndex);\n\n    // Remove eldest entry if instructed, else grow capacity if appropriate\n    Entry<K,V> eldest = header.after;\n    if (removeEldestEntry(eldest)) {\n        removeEntryForKey(eldest.key);\n    } else {\n        if (size >= threshold)\n            resize(2 * table.length);\n    }\n}\n\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    HashMap.Entry<K,V> old = table[bucketIndex];\n\tEntry<K,V> e = new Entry<K,V>(hash, key, value, old);\n    table[bucketIndex] = e;\n    e.addBefore(header); //每次都是在对应桶链表的开始处添加\n    size++;\n}\n\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n    return false;\n}\n```\nget方法\n```\npublic V get(Object key) {\n    Entry<K,V> e = (Entry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    e.recordAccess(this); //实现LRU\n    return e.value;\n}\n//重写父类方法，效率更高O(size)\npublic boolean containsValue(Object value) {\n    // Overridden to take advantage of faster iterator\n    if (value==null) {\n        for (Entry e = header.after; e != header; e = e.after)\n            if (e.value==null)\n                return true;\n    } else {\n        for (Entry e = header.after; e != header; e = e.after)\n            if (value.equals(e.value))\n                return true;\n    }\n    return false;\n}\n```\n###视图和迭代器###\n\n`LinkedHashMap`同样继承了创建3个集合类视图：键集合、值集合、键值对集合的方法，由于额外维护一个双向链表保证迭代顺序，重写了相关视图的迭代器实现，`LinkedHashIterator`通过直接迭代链表的header指针来实现指定顺序遍历。\n```\nIterator<K> newKeyIterator()   { return new KeyIterator();   }\nIterator<V> newValueIterator() { return new ValueIterator(); }\nIterator<Map.Entry<K,V>> newEntryIterator() { return new EntryIterator(); }\n\nprivate class KeyIterator extends LinkedHashIterator<K> {\n\tpublic K next() { return nextEntry().getKey(); }\n}\n\nprivate class ValueIterator extends LinkedHashIterator<V> {\n\tpublic V next() { return nextEntry().value; }\n}\n\nprivate class EntryIterator extends LinkedHashIterator<Map.Entry<K,V>> {\n\tpublic Map.Entry<K,V> next() { return nextEntry(); }\n}\n\nprivate abstract class LinkedHashIterator<T> implements Iterator<T> {\n\tEntry<K,V> nextEntry    = header.after;\n\tEntry<K,V> lastReturned = null;\n\tint expectedModCount = modCount;\n\t\n\tpublic boolean hasNext() {\n        return nextEntry != header;\n\t}\n\n\tpublic void remove() {\n\t    if (lastReturned == null)\n\t\t\tthrow new IllegalStateException();\n\t    if (modCount != expectedModCount)\n\t\t\tthrow new ConcurrentModificationException();\n\n        LinkedHashMap.this.remove(lastReturned.key);\n        lastReturned = null;\n        expectedModCount = modCount;\n\t}\n\n\tEntry<K,V> nextEntry() {\n\t    if (modCount != expectedModCount)\n\t\t\tthrow new ConcurrentModificationException();\n        if (nextEntry == header)\n            throw new NoSuchElementException();\n\n        Entry<K,V> e = lastReturned = nextEntry;\n        nextEntry = e.after;\n        return e;\n\t}\n}\n```\n###总结###\n\n1. `LinkedHashMap`继承自`HashMap`，相关基本操作性能略低于`HashMap`，由于需要额外代价维护链表。其遍历操作是通过操作该双向链表实现，而非内部散列表数组，因此性能为O(size)比`HashMap`O(capacity)更高。\n2. 支持两种顺序遍历：元素插入顺序(重复put不算)和最近使用优先顺序(调用put和get类似LRU)，默认是按照元素插入顺序遍历。通过构造函数传入true可以实现最近使用优先遍历，每次put或get操作时，将该元素直接重新放置到链表头结点后面来实现最近使用优先遍历。\n3. `LinkedHashMap`并没有重新创建一个新的链表来实现顺序遍历，而是在每个Entry上多加了两个指针来决定遍历顺序，有效节约了空间消耗。实际只比`HashMap`多了2*size个引用+1个头结点空间消耗。\n4. `LinkedHashMap`支持元素淘汰策略，可以通过重写`removeEldestEntry`方法，来决定调用put时候是否需要删除旧的元素。`LinkedHashMap`可以用于实现LRU缓存，并自定义元素淘汰策略。"}