{"text":"###Executor框架\n每当启动线程的时候，希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread。\n线程池是指管理一组同结构工作线程的资源池，线程池与工作队列(Work Queue)密切相关。线程池通过重用已有的线程而非创建新线程，可以避免创建和销毁线程产生的巨大开销。可以通过`Executors`中静态工厂方法来创建线程池：\n\n- newFixedThreadPool，创建一个固定长度的线程池，采用无界队列LinkedBlockingQueue\n- newCachedThreadPool，创建一个可缓存的线程池，若线程池当前规模超过处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程。\n- newSingleThreadExecutor，一个单线程的Executor，采用无界队列LinkedBlockingQueue\n- newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。\n\n**Executor的生命周期**\n为了提供生命周期管理，`ExecutorService`接口扩展了`Executor`接口，添加一些生命周期管理方法如下。\n```\npublic interface ExecutorService extends Executor {\n    void shutdown();\n    List<Runnable> shutdownNow();\n    boolean isShutdown();\n    boolean isTerminated();\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n}\n```\n`ExecutorService`声明周期有三种状态：运行、关闭和终止。\n`shutdown`方法将执行平缓的关闭过程，不再接受新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务。\n`shutdownNow`方法将执行粗暴的关闭过程，将尝试取消所有运行中的任务，并且不再启动队列中尚未开始的任务。\n`ExecutorService`关闭后提交的任务将由\"拒绝执行处理器(Rejected Execution Handler)来处理\"，它将会抛弃任务，或者使得execute方法抛出一个未检查异常RejectedExecutionException。\n所有任务都完成后，ExecutorService进入终止状态，可以通过`isTerminated()`来轮询判断是否终止，通常在调用`awaitTermination`之后立即调用`shutdown`方法，从而产生异步关闭的效果。\n\n**延迟任务和周期任务**\n`Timer`负责管理延迟任务和周期任务，然而其存在一些缺陷，因此应该考虑使用`ScheduledThreadPoolExecutor`来代替，可以通过其构造方法或者`newScheduledThreadPool`工厂方法来创建该对象。\n\nTimer缺陷\n\n- Timer在执行所有定时任务时只会创建一个线程，若某个任务的执行时间过长，将会破坏其他TimerTask的定时精确性。\n- 若TimerTask抛出未检查的异常而终止定时线程时，由于Timer线程并不捕获异常，Timer将不会恢复线程的执行，新的任务将不能被调度。\n\n若需要构建自己的调度服务，那么可以使用`DelayQueue`，其实现了`BlockingQueue`，并为`ScheduledThreadPoolExecutor`提供调度功能。其管理一组Delay对象，只有某个元素逾期后，才能执行take操作。\n\n**Callable和Future**\n`Callable`用于取代`Runnable`，其表示的任务拥有返回值，并可以抛出受检查异常。\n`Future`表示一个任务的生命周期，并提供相应的方法判断任务是否完成或取消，以及获取任务的执行结果和取消任务等。任务的生命周期只能前进不能后退。\nget方法取决于任务的状态(尚未开始、正在运行、已完成) ，若已完成则会立即返回或者抛出一个Exception，若任务没有完成则get将阻塞直到任务完成。若任务抛出异常，则get将该异常封装为ExecutionException重新抛出。如果任务被取消，那么将抛出CancellationException。\n```\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n\npublic interface Future<V> {\n    boolean cancel(bool mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException, CancellationException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, CancellationException;\n}\n```\n**CompletionService**\n如果向Executor提交一组计算任务，并且希望在计算完成后获取结果，可以利用`CompletionService`，`CompletionService`将Executor和BlockingQueue的功能融合在一起，可以讲Callable任务提交给Executor来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果在完成时被封装为Future。\n\n`ExecutorCompletionService`实现了CompletionService，并将计算部分委托给一个Executor。其实现非常简单，构造函数中创建一个BlockingQueue来保存计算结果。当计算完成时，调用Future-Task中的done方法；当提交某个任务时，该任务先包装为QueueingFuture，这是FutureTask的子类，然后再改下done方法，并将结果放入BlockingQueue中。\n\n###取消和关闭\n线程中断时一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他工作。\n```\npublic class Thread {\n    public void interrupt() {...}\n    public boolean isInterrupted() { ... }\n    public static interrupted() { ...} //清除中断状态\n}\n```\n阻塞库方法如Thread.sleep和Object.wait，都会检查线程何时中断，并且在发现中断时提前返回。其在响应中断执行的操作包括：清除中断状态、抛出InterruptedExeception，表示阻塞操作由于中断而结束。\n中断并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。\n**中断策略**：某种形式的线程级取消操作或服务级取消操作，尽快推出，在必要时清理，通知某个所有者该线程已经退出，。\n**响应中断**：只有实现了线程中断策略的代码才可以屏蔽中断请求，在常规的任务和库代码中都不应该屏蔽中断请求。\n\n**不可中断的阻塞**\n\n- java.io包中的同步Socket I/O\n- java.io包中的同步I/O\n- Selector的异步IO\n- 获取某个锁\n\nJAVA6中在`ThreadPoolExecutor`新增newTaskFor方法,将Callable对象封装为`RunnableFuture`可以调用其cancel方法进行取消操作。\n```\nprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n    return new FutureTask<T>(callable);\n}\n```\n\n在任务、线程、服务以及应用程序等模块中的生命周期结束问题，Java并没有提供抢占式的机制来取消操作或者终结线程，相反其**提供一种协作式的中断机制来实现取消操作**，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用FutureTask和Executor框架，可以帮助构建可取消的任务和服务。\n\n###线程池的使用\n在线程池中，如果任务依赖于其他任务，那么可能产生死锁。如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞，这种现象称为饥饿死锁。\n\n**运行较长时间的任务**：线程池的响应性会变得很差，可以通过限定任务等待资源的时间，而不要无限等待来缓解执行较长任务带来的影响。大多数可阻塞方法都提供了限时版和无限时版，如Thread.join、BlockingQueue.put、CountDownLatch.await、Selector.select等。\n\n**设置线程池的大小**\nCPU密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的利用率。I/O密集型的任务，往往设置更大的大小的线程池。\n可以通过`Runtime.getRuntime().availableProceesors`获取处理器数量。\n\n**配置ThreadPoolExecutor**\nThreadPoolExecutor是一个灵活的、稳定的线程池，允许进行各种定制。Executors中工厂方法也是该类不同参数返回的实例。\n```\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, \n    long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, \n    ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n}\n```\n- corePoolSize线程池的基本大小\n- maximumPoolSize线程池的最大大小\n- keepAliveTime和unit，线程池中空闲线程存活时间\n- workQueue任务队列来保存等待执行的任务\n- threadFactory线程工厂\n- handler饱和策略\n\n任务队列有3种：无界队列、有界队列和同步移交(Synchronous Handoff)。\n\n- newFixedThreadPool和newSingleThreadExecutor默认都是使用一个无界的LinkedBlocingQueue。\n- 一种更稳妥的资源管理策略是使用有界队列，例如ArrayBlockingQueue、有界的LinkedBlocingQueue和PriorityBlockingQueue。当有界队列填满后，新的任务如何处理，这个时候需要饱和策略来处理。\n- 对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchronousQueue不是一个真正的队列，而是一种线程之间进行移交的机制。\n\n**饱和策略**\n`ThreadPoolExecutor`的饱和策略可以通过调用`setRejectedExecutionHandler`来修改。JDK提供几种不同的`RejectedExecutionHandler`实现。\n\n- `AbortPolicy`(中止策略)：默认饱和策略，将抛出未检查的`RejectedExecutionException`，新提交任务无法保存到任务队列中。\n- `DiscardPolicy`(抛弃策略)：会悄悄抛弃新提交的任务\n- `DiscardOldestPolicy`(抛弃最旧策略)：会抛弃下一个将被执行的任务，然后尝试重新提交新的任务(最好不要和PriorityQueue一起使用，否则会抛弃优先级最高的线程)。\n- `CallerRunsPolicy`(调用者运行策略)：该策略既不会抛弃任务，也不好抛出异常，而是将某些任务退回到调用者，从而降低新任务的流量。\n\n###图形用户界面程序GUI\n几乎所有的GUI工具包(Swing和AWT，以及Qt、MacOS Cocoa、X Windows)都被实现为单线程子系统，所有的GUI操作都被限制在单个线程中。早期的GUI应用程序都是单线程的，并且GUI事件在“主事件循环”进行处理。\n当前GUI程序使用一种略不同模型：在该模型中创建一个专门的事件分发线程(Event Dispatch Thread，EDT)来处理GUI事件。\n许多尝试编写多线程GUI框架都以失败告终，主要由于竞态条件和死锁导致的稳定性问题。单线程GUI框架，采用一个专门的线程从队列中抽取事件，并将它们转发到应用程序定义的事件处理器，其通过线程封闭机制实现线程安全。所有GUI对象，包括可视化组件和数据模型等，都只能在事件线程中访问。\n\nSwing的单线程规则：Swing中组件以及模型只能在这个事件分发线程中进行创建、修改以及查询。少数方法可以安全的从其他线程访问：\n\n- `SwingUtilities.isEventDispatchThread`用于判断当前线程是否为事件线程\n- `SwingUtilities.invokeLater`，可以将一个Runnable任务调度到事件线程中执行，并阻塞当前线程直到任务完成\n- `SwingUtilities.invokeAndWait`该方法可以将一个Runnable任务调度到事件线程中执行，并阻塞当前线程直到任务完成(只能从非GUI线程中调用)\n- 所有将重绘请求或重生效请求插入队列的方法\n- 所有添加或移除监听器的方法\n\n可以将Swing的事件线程视为一个单线程的Executor，它处理来自事件队列的任务。在事件线程中不应执行事件较长的操作，以免用户界面失去了响应，对于这种较长事件任务应该单独另启动新的线程进行操作，如Swing中`SwingWorker`。\n"}