{"text":"**意图**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**适用性**\n\n- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现\n- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复\n- 控制子类扩展。模板方法只在特定点调用“ hook”操作，这样就只允许在这些点进行扩展\n\n**结构**\n![enter image description here][1]\n\n**参与者**\n\n- AbstractClass：定义抽象的 原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法的各步骤。实现一个模板方法 ，定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作\n- ConcreteClass：实现原语操作以完成算法中与特定子类相关的步骤\n\n**协作**\nConcreteClass靠AbstractClass来实现算法中不变的步骤。\n\n**效果**\n\n- 模板方法是一种代码复用的基本技术。\n- 模板方法导致一种反向的控制结构，这种结构有时被称为“好莱坞法则”，即“别找我们，我们找你”。这指的是一个父类调用一个子类的操作，而不是相反。\n- 钩子操作 （ hook operations），它提供了缺省的行为，子类可以在必要时进行扩展。模板方法应该指明哪些操作是钩子操作，以及哪些是抽象操作。\n\n**JDK中实例**\n\n- `javax.servlet.http.HttpServlet`, all the `doXXX()` methods by default sends a HTTP 405 \"Method Not Allowed\" error to the response. You're free to implement none or any of them.\n- All non-abstract methods of `java.util.AbstractList`, `java.util.AbstractSet` and `java.util.AbstractMap`.\n- All non-abstract methods of `java.io.InputStream`, `java.io.OutputStream`, `java.io.Reader` and `java.io.Writer`.\n  [1]: http://img.itc.cn/photo/j3njhHcaw6G"}