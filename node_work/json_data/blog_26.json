{"text":"###装饰模式\n**意图**：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。\n**动机**：有时我们希望给某个对象而不是整个类添加一些功能。使用继承机制是添加功能的一种有效途径，但这种方法不够灵活；一种较为灵活的方式是将组件嵌入另一个对象中。\n**适用性**：\n\n- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n- 处理那些可以撤消的职责\n- 当不能采用生成子类的方法进行扩充时\n\n**结构**\n![enter image description here][1]\n**参与者**：\n\n- Component：顶一个一个对象接口，可以给这些对象动态地添加职责\n- ConcreteComponent：定义一个对象，可以给这个对象添加一些职责\n- Decorator：维持一个指向Componet对象的指针，并定义一个与Component接口一致的接口\n- ConcreteComponent：向组件添加职责\n\n**协作**：\nDecorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作\n\n**效果**\n\n- 比静态继承更灵活。可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。\n- 避免在层次结构高层的类有太多的特征\n- Decorator与它的Component不一样，Decorator是一个透明的包装\n- 有许多小对象\n\n**实现**\n\n- 接口的一致性，装饰对象的接口必须与它所装饰的Component的接口一致\n- 省略抽象的Decorator类，当你仅需要添加一个职责时，没有必要定义抽象Decorator类\n- 保持Component类的简单性\n- 改变对象外壳与改变对象内核，可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为；Strategy模式就是一个用于改变内核的很好的模式\n\n**扩展**\n1.  若只有一个ConcreteDecorator时，没必要提供Decorator类，例如JDK中`BufferedInputStream`\n2.  透明和半透明装饰模式\n透明装饰模式：ConcreteDecorator不含有Component中没有定义的public方法(DIP)\n半透明装饰模式：增加功能公共方法可以定义在ConcreteDecorator中\n\n###JDK中实例\n- `java.util.Collections`, the `checkedXXX()`, `synchronizedXXX()` and `unmodifiableXXX()` methods.\n- `javax.servlet.http.HttpServletRequestWrapper` and `HttpServletResponseWrapper`\n- `java.io.FilterInputStream`、`java.io.FilterOutputStream`\n![enter image description here][2]\n\n\n  [1]: http://img.itc.cn/photo/jtKXFJE53Qt\n  [2]: http://img.itc.cn/photo/jtKRr7HCQd2"}