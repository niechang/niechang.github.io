{"text":"###Set相关类\n![Alt text](http://img.itc.cn/photo/jt8og7u6buV)\n\n- HashSet:一种没有重复元素的无序集合\n- LinkedHashSet:一种可以记住元素插入次序的没有重复元素的集合\n- TreeSet:一种没有重复元素的有序集合\n- EnumSet:一种包含枚举类型值的集合\n- BitSet:一个比特Set，没有实现Set接口\n\n###HashSet的实现###\n`HashSet`实现了`Set`接口，通过散列表来支持实际是`HashMap`实例。不能保证插入的顺序，支持`null`值插入。和散列表类似，通常元素可以分散分布在不同桶中，对于基本操作提供常数时间(add,remove,contains,size)。\n\n`HashSet`是非线性安全的，多线程环境下，保证最多只有一个线程修改容器，可以采用以下包裹方式`Set s = Collections.synchronizedSet(new HashSet(...));`返回线程安全的`Set`。\n\n**类的定义**\n```\npublic class HashSet<E>\n\textends AbstractSet<E>\n\timplements Set<E>, Cloneable, java.io.Serializable\n```\n\n**成员**\n```\nprivate transient HashMap<E,Object> map;\t\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\n```\n`HashMap`中的key是不重复的，`HashSet`利用这点委托给`HashMap`来实现，每次添加一个元素都是在散列表中加入key和一个没用的值。\n\n**方法**\n\t\n`HashSet`中相关方法都是通过`HashMap`来实现的，这里不细述，可以参考介绍`HashMap`源码。重新实现了序列化相关方法，并不需要序列化整个map，而只需要序列化所有的key值，以及其他必要字段如大小，装填因子等。\n\n```\npublic HashSet() {\n\tmap = new HashMap<E,Object>();\n}\n\npublic boolean add(E e) {\n\treturn map.put(e, PRESENT)==null;\n}\n\npublic boolean remove(Object o) {\n\treturn map.remove(o)==PRESENT;\n}\n\npublic Iterator<E> iterator() {\n\treturn map.keySet().iterator();\n}\n\n//序列化方法，只需要序列化必要字段和所有key值\nprivate void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n\t// Write out any hidden serialization magic\n\ts.defaultWriteObject();\n    // Write out HashMap capacity and load factor\n    s.writeInt(map.capacity());\n    s.writeFloat(map.loadFactor());\n    // Write out size\n    s.writeInt(map.size());\n\t// Write out all elements in the proper order.\n\tfor (Iterator i=map.keySet().iterator(); i.hasNext(); )\n            s.writeObject(i.next());\n}\n\nprivate void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n\t// Read in any hidden serialization magic\n\ts.defaultReadObject();\n    // Read in HashMap capacity and load factor and create backing HashMap\n    int capacity = s.readInt();\n    float loadFactor = s.readFloat();\n    map = (((HashSet)this) instanceof LinkedHashSet ?\n           new LinkedHashMap<E,Object>(capacity, loadFactor) :\n           new HashMap<E,Object>(capacity, loadFactor));\n    // Read in size\n    int size = s.readInt();\n    // Read in all elements in the proper order.\n    for (int i=0; i<size; i++) {\n        E e = (E) s.readObject();\n        map.put(e, PRESENT);\n    }\n}\n```\n\n###LinkedHashSet的实现\n`LinkedHashSet`是利用散列表和链表实现Set接口，能够保证迭代的顺序(按照添加的顺序)。其实内部是通过`LinkedHashMap`实现，因此也是通过一个双向链表来记录元素插入的位置。类的定义，可以看到直接继承了`HashSet`，本身只有若干重载的构造函数，调用父类构造函数的时候会将map设置为`LinkedHashMap`实例。\n\n```\npublic class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable {\n    \n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true); //HashSet构造函数\n    }\n}\n\n//map初始化为LinkedHashMap\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n\tmap = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);\n}\n```\n\n###TreeSet的实现\n基于`TreeMap`实现的`NavigableSet`，元素按照自然顺序(key实现了`Comparable`)或者通过初始化时传入的`Comparator`来指定。\n```\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable{\n        \n    private transient NavigableMap<E,Object> m;\n    \n    private static final Object PRESENT = new Object();\n    \n    public TreeSet() {\n\t    this(new TreeMap<E,Object>());\n    }\n    \n    public boolean add(E e) {\n\t    return m.put(e, PRESENT)==null;\n    }\n    \n    public boolean contains(Object o) {\n\t    return m.containsKey(o);\n    }\n    \n    public Iterator<E> iterator() {\n        return m.navigableKeySet().iterator();\n    }\n    \n    public NavigableSet<E> descendingSet() {\n\t    return new TreeSet(m.descendingMap());\n    }\n}\n```"}