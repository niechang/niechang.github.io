{"text":"###TreeMap\n- TreeMap是一个基于红黑树的`NavigableMap`实现，map的顺序是根据其keys的自然顺序(compareTo方法key对象实现`Comparable`)决定的，或者在map创建时候传入一个`Comparator`，这两张比较策略根据选择的构造函数决定。\n- 保证containsKey, get, put, remove操作的时间复杂度为O(logn)。\n- TreeMap是非同步的，多线程下不能保证线程安全，若需要在多线程下使用，可以对其进行包裹`SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));`。\n- TreeMap集合视图返回的迭代器支持`fail-fast`。\n\n###TreeMap的实现之红黑树\n一般的，红黑树首先是一种二叉查找树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：[july博客](http://www.cnblogs.com/v-July-v/archive/2010/12/29/1983707.html)\n1. 每个结点要么是红的，要么是黑的。\n2. 根结点是黑的。\n3. 每个叶结点，即空结点（NIL）是黑的。\n4. 如果一个结点是红的，那么它的俩个儿子都是黑的。\n5. 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\n\n**类的定义**，相比其他类型HashMap多一个`NavigableMap`接口，该接口继承了`SortedMap`。\n```\npublic class TreeMap<K,V>\n    extends AbstractMap<K,V>\n    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n```\n\n**成员变量**\n\n```\n//用于维护tree map的顺序, 如果用key的自然顺序则为null\nprivate final Comparator<? super K> comparator;\n//red black tree root\nprivate transient Entry<K,V> root = null;\nprivate transient int size = 0;\nprivate transient int modCount = 0;\n\nstatic final class Entry<K,V> implements Map.Entry<K,V> {\n\tK key;\n    V value;\n    Entry<K,V> left = null;\n    Entry<K,V> right = null;\n    Entry<K,V> parent;\n    boolean color = BLACK; //默认是黑色\n    \n    Entry(K key, V value, Entry<K,V> parent) {\n        this.key = key;\n        this.value = value;\n        this.parent = parent;\n    }\n}\n```\n###插入方法\nput插入方法，实际每次插入的节点都设置为红色，则只可能违背上述**规则2**根节点是黑的和**规则4**红节点的儿子节点是黑的，应对策略：\n其一、把出现违背红黑树性质的结点向上移，如果能移到根结点，那么很容易就能通过直接修改根结点来恢复红黑树的性质。直接通过修改根结点来恢复红黑树应满足的性质。\n其二、穷举所有的可能性，之后把能归于同一类方法处理的归为同一类。不能直接处理的化归到下面的几种情况\n**情况1**：插入的是根结点。原树是空树，此情况只会违反性质2。直接把此结点涂为黑色。\n**情况2**：插入的结点的父结点是黑色。此不会违反性质2和性质4，红黑树没有被破坏。什么也不做。\n**情况3**：当前结点的父结点是红色，且叔叔结点也是红色。(分为当前结点是其父结点的左子还是右子，处理方式对称)\n**对策**：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法。\n**情况4**：当前结点的父结点是红色，且叔叔结点是黑色，当前结点是其父结点的右子。\n**对策**：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。\n**情况5**：当前节点的父节点是红色，叔叔节点是黑色，当前节点是其父节点的左子。\n**对策**：父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋\n```\n public V put(K key, V value) {\n    Entry<K,V> t = root;\n    if (t == null) { //情况1：插入的是根结点，违背规则2\n        root = new Entry<K,V>(key, value, null);\n        size = 1;\n        modCount++;\n        return null;\n    }\n    int cmp;\n    Entry<K,V> parent;\n    // split comparator and comparable paths\n    Comparator<? super K> cpr = comparator;\n    if (cpr != null) {\n        do {\n            parent = t;\n            cmp = cpr.compare(key, t.key); \n            if (cmp < 0) //key < t.key\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    else {\n        if (key == null)\n            throw new NullPointerException();\n        Comparable<? super K> k = (Comparable<? super K>) key;\n        do {\n            parent = t;\n            cmp = k.compareTo(t.key);\n            if (cmp < 0) //key < t.key\n                t = t.left;\n            else if (cmp > 0)\n                t = t.right;\n            else\n                return t.setValue(value);\n        } while (t != null);\n    }\n    Entry<K,V> e = new Entry<K,V>(key, value, parent);\n    if (cmp < 0)\n        parent.left = e;\n    else\n        parent.right = e;\n    fixAfterInsertion(e);\n    size++;\n    modCount++;\n    return null;\n}\n\n/** From CLR */\nprivate void fixAfterInsertion(Entry<K,V> x) {\n    x.color = RED; //当前节点设为红色\n\n    while (x != null && x != root && x.parent.color == RED) {//违背规则4,父节点也是红色\n        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { //父节点为祖父节点的左孩子\n            Entry<K,V> y = rightOf(parentOf(parentOf(x))); //叔叔节点(祖父节点右孩子)\n            if (colorOf(y) == RED) { //情况3：叔叔节点是红色\n                setColor(parentOf(x), BLACK); //父节点设为黑色\n                setColor(y, BLACK); //叔叔节点也设为黑色\n                setColor(parentOf(parentOf(x)), RED); //祖父节点设为红色\n                x = parentOf(parentOf(x)); //当前节点设为祖父节点(上移到祖父节点)\n            } else { //叔叔节点是黑色(父节点是红色,祖父节点是黑色)\n                if (x == rightOf(parentOf(x))) { //情况4：叔叔为黑节点，当前节点为父节点的右孩子\n                    x = parentOf(x); //当前节点设为父节点\n                    rotateLeft(x); //左旋，红节点为其父节点的左孩子case5\n                }\n                //情况5：叔叔结点是黑色，当前结点是其父结点的右子\n                setColor(parentOf(x), BLACK); //父节点设为黑色\n                setColor(parentOf(parentOf(x)), RED); //祖父节点设为红色\n                rotateRight(parentOf(parentOf(x))); //以祖父节点为支点右旋\n            }\n        } else { //对称情况，父节点为祖父节点的右孩子\n            Entry<K,V> y = leftOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {\n                setColor(parentOf(x), BLACK);\n                setColor(y, BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                x = parentOf(parentOf(x));\n            } else {\n                if (x == leftOf(parentOf(x))) {\n                    x = parentOf(x);\n                    rotateRight(x);\n                }\n                setColor(parentOf(x), BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                rotateLeft(parentOf(parentOf(x)));\n            }\n        }\n    }\n    root.color = BLACK;\n}\n\nprivate static <K,V> Entry<K,V> parentOf(Entry<K,V> p) {\n    return (p == null ? null: p.parent);\n}\n```\n\n###删除方法\n红黑树的删除方法和不同二叉查找树的删除方法类似:\n- 若被删除节点有一个孩子非空其另一个为空，直接删除该节点，用唯一的子节点替换它的位置\n- 若被删除节点是双空子女，直接删除后用空节点替换它的位置；\n- 若两个孩子都非空，找到并复制它的直接后继节点内容到它的位置，一同样方式删除该直接后继节点。\n\n**情况1**：x的兄弟w是红色的。\n**对策**：改变w(变为黑色)和parent(x)(变为红色)颜色，以parent(x)为支点左旋，x的新兄弟new w是旋转之前w的某个孩子，为黑色，情况1转化为情况2或3,4\n**情况2**：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。\n**对策**：因为w也是黑色的，所以x和w中得去掉一黑色，最后将w变为红，x = parent(x)\n**情况3**：x的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。\n**对策**：交换w和和其左孩子left[w]的颜色，并对w进行右旋，而红黑性质仍然得以保持，现在x的新兄弟w是一个有红色右孩子的黑结点，于是将情况3转化为情况4\n**情况4**：x的兄弟w是黑色的，且w的右孩子时红色的。\n**对策**：做颜色修改，并对p[x]做一次旋转，可以去掉x的额外黑色，来把x变成单独的黑色，此举不破坏红黑性质。将x置为根后，循环结束。\n```\npublic V remove(Object key) {\n    Entry<K,V> p = getEntry(key);\n    if (p == null)\n        return null;\n    V oldValue = p.value;\n    deleteEntry(p);\n    return oldValue;\n}\n\n// Delete node p, and then rebalance the tree.\nprivate void deleteEntry(Entry<K,V> p) {\n    modCount++;\n    size--;\n    // If strictly internal, copy successor's element to p and then make p point to successor.\n    if (p.left != null && p.right != null) { //左右孩子均不为空\n        Entry<K,V> s = successor (p); //p的后继，第一个比p大的元素(p的右孩子最左的元素)\n        p.key = s.key;\n        p.value = s.value; //复制直接后继节点内容至p\n        p = s; //p设为直接后继节点,删除该直接后继(肯定不会有两个非空孩子节点)\n    } // p has 2 children\n    // Start fixup at replacement node, if it exists.\n    Entry<K,V> replacement = (p.left != null ? p.left : p.right);\n\n    if (replacement != null) {\n        // Link replacement to parent\n        replacement.parent = p.parent;\n        if (p.parent == null)\n            root = replacement;\n        else if (p == p.parent.left)\n            p.parent.left  = replacement;\n        else\n            p.parent.right = replacement;\n\n        // Null out links so they are OK to use by fixAfterDeletion.\n        p.left = p.right = p.parent = null;\n        // Fix replacement，删除节点为黑色，违背规则5\n        if (p.color == BLACK)\n            fixAfterDeletion(replacement);\n    } else if (p.parent == null) { // return if we are the only node.\n        root = null;\n    } else { //  No children. Use self as phantom replacement and unlink.\n        if (p.color == BLACK)\n            fixAfterDeletion(p);\n\n        if (p.parent != null) {\n            if (p == p.parent.left)\n                p.parent.left = null;\n            else if (p == p.parent.right)\n                p.parent.right = null;\n            p.parent = null;\n        }\n    }\n}\n\n/** From CLR */\nprivate void fixAfterDeletion(Entry<K,V> x) {\n    while (x != root && colorOf(x) == BLACK) {\n        if (x == leftOf(parentOf(x))) { //x为左孩子\n            Entry<K,V> sib = rightOf(parentOf(x)); //兄弟节点\n\n            if (colorOf(sib) == RED) { //case 1: 兄弟节点是红\n                setColor(sib, BLACK); //兄弟节点变为黑\n                setColor(parentOf(x), RED);//父节点变为红\n                rotateLeft(parentOf(x)); //以父节点左旋\n                sib = rightOf(parentOf(x)); //重新设置兄弟节点new w(为原来w的某个孩子黑色)\n            }\n\n            if (colorOf(leftOf(sib))  == BLACK &&\n                colorOf(rightOf(sib)) == BLACK) {//case 2:兄弟节点左右孩子都是黑色\n                setColor(sib, RED);\n                x = parentOf(x);\n            } else { \n                if (colorOf(rightOf(sib)) == BLACK) {//case 3:兄弟节点右孩子是黑色，左孩子是红色\n                    setColor(leftOf(sib), BLACK);\n                    setColor(sib, RED);\n                    rotateRight(sib);\n                    sib = rightOf(parentOf(x));\n                }\n                //case 4:兄弟节点右孩子是红色\n                setColor(sib, colorOf(parentOf(x)));\n                setColor(parentOf(x), BLACK);\n                setColor(rightOf(sib), BLACK);\n                rotateLeft(parentOf(x));\n                x = root;\n            }\n        } else { // symmetric\n            Entry<K,V> sib = leftOf(parentOf(x));\n\n            if (colorOf(sib) == RED) {\n                setColor(sib, BLACK);\n                setColor(parentOf(x), RED);\n                rotateRight(parentOf(x));\n                sib = leftOf(parentOf(x));\n            }\n\n            if (colorOf(rightOf(sib)) == BLACK &&\n                colorOf(leftOf(sib)) == BLACK) {\n                setColor(sib, RED);\n                x = parentOf(x);\n            } else {\n                if (colorOf(leftOf(sib)) == BLACK) {\n                    setColor(rightOf(sib), BLACK);\n                    setColor(sib, RED);\n                    rotateLeft(sib);\n                    sib = leftOf(parentOf(x));\n                }\n                setColor(sib, colorOf(parentOf(x)));\n                setColor(parentOf(x), BLACK);\n                setColor(leftOf(sib), BLACK);\n                rotateRight(parentOf(x));\n                x = root;\n            }\n        }\n    }\n\n    setColor(x, BLACK);\n}\n```\n**Get方法**实际是二叉查找树的搜索过程，复杂度为O(lgn)\n```\npublic V get(Object key) {\n    Entry<K,V> p = getEntry(key);\n    return (p==null ? null : p.value);\n}\nfinal Entry<K,V> getEntry(Object key) {\n    // Offload comparator-based version for sake of performance\n    if (comparator != null)\n        return getEntryUsingComparator(key);\n    if (key == null)\n        throw new NullPointerException();\nComparable<? super K> k = (Comparable<? super K>) key;\n    Entry<K,V> p = root;\n    while (p != null) {\n        int cmp = k.compareTo(p.key);\n        if (cmp < 0) //key <　p.key\n            p = p.left;\n        else if (cmp > 0)\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n\n```\n\n###集合视图和迭代器\n`TreeMap`和其他Map最大不同是遍历过程保持keys的自然顺序，也可以指定排序器`Comparator`来确定顺序，其顺序的信息实际包含在一棵二叉查找树中，通过中根序遍历就可以得到一个从小到大的顺序。其顺序性可以通过返回的集合视图对象来反映。同样提供`keySet()`, `values()`, `entrySet()`方法返回键集合、值集合和键值对集合。此外还提供一个`descendingMap`视图，返回一个逆序的子Map。\n\n`keySet()`方法返回的实际是`NavigableSet`对象，方法都是委托给`TreeMap`相应的方法。这里关注迭代器方法，有两个迭代器`iterator()`和`descendingIterator()`，分别代表升序和降序遍历两种。\n\n`descendingIterator()`方法定义在`NavigableSet`中，需要逆序迭代可以通过`descendingMap`视图，然后在该map上调用相应集合视图的`iterator`逆序，`descendingIterator()`变回了正序。但是不能直接在treeMap实例调用`(NavigableSet)map.keySet().descendingIterator()`。这是由于`descendingKeySet()`是通过`descendingMap()`返回的`TreeMap$DescendingSubMap`实例，其定义了不同的KeySet和Iterator。\n\n```\ntransient volatile Collection<V> values = null; //定义在AbstractMap中\nprivate transient EntrySet entrySet = null;\nprivate transient KeySet<K> navigableKeySet = null;\nprivate transient NavigableMap<K,V> descendingMap = null;\n    \npublic Set<K> keySet() {\n    return navigableKeySet();\n}\npublic NavigableSet<K> navigableKeySet() {\n    KeySet<K> nks = navigableKeySet;\n    return (nks != null) ? nks : (navigableKeySet = new KeySet(this));\n}\npublic NavigableSet<K> descendingKeySet() {\n    return descendingMap().navigableKeySet();\n}\npublic NavigableMap<K,V> descendingMap() {\n    NavigableMap<K,V> mv = descendingMapView; //降序map视图对象\n    return (mv != null) ? mv :\n        (descendingMapView =\n         new AscendingSubMap(m,\n                             fromStart, lo, loInclusive,\n                             toEnd,     hi, hiInclusive));\n}\n\nstatic final class KeySet<E> extends AbstractSet<E> implements NavigableSet<E> {\n    private final NavigableMap<E, Object> m;\n    KeySet(NavigableMap<E,Object> map) { m = map; }\n\n    public Iterator<E> iterator() {\n        if (m instanceof TreeMap)\n            return ((TreeMap<E,Object>)m).keyIterator();\n        else\n            return (Iterator<E>)(((TreeMap.NavigableSubMap)m).keyIterator());\n    }\n\n    public Iterator<E> descendingIterator() {\n        if (m instanceof TreeMap)\n            return ((TreeMap<E,Object>)m).descendingKeyIterator();\n        else\n            return (Iterator<E>)(((TreeMap.NavigableSubMap)m).descendingKeyIterator());\n    }\n\n    public int size() { return m.size(); }\n    public boolean isEmpty() { return m.isEmpty(); }\n    public boolean contains(Object o) { return m.containsKey(o); }\n    public void clear() { m.clear(); }\n    public E lower(E e) { return m.lowerKey(e); }\n    public E higher(E e) { return m.higherKey(e); }\n    ...\n}\n\nIterator<K> keyIterator() {\n    return new KeyIterator(getFirstEntry());\n}\nIterator<K> descendingKeyIterator() {\n    return new DescendingKeyIterator(getFirstEntry());\n}\n\nfinal Entry<K,V> getFirstEntry() {\n    Entry<K,V> p = root;\n    if (p != null)\n        while (p.left != null)\n            p = p.left;\n    return p;\n}\n\nfinal class KeyIterator extends PrivateEntryIterator<K> {\n    KeyIterator(Entry<K,V> first) {\n        super(first);\n    }\n    public K next() {\n        return nextEntry().key; //下一个entry的key\n    }\n}\nfinal class DescendingKeyIterator extends PrivateEntryIterator<K> {\n    DescendingKeyIterator(Entry<K,V> first) {\n        super(first);\n    }\n    public K next() {\n        return prevEntry().key; //前一个entry的key\n    }\n}\n\nabstract class PrivateEntryIterator<T> implements Iterator<T> {\n    Entry<K,V> next;\n    Entry<K,V> lastReturned;\n    int expectedModCount;\n\n    PrivateEntryIterator(Entry<K,V> first) {\n        expectedModCount = modCount;\n        lastReturned = null;\n        next = first;\n    }\n\n    public final boolean hasNext() {\n        return next != null;\n    }\n\n    final Entry<K,V> nextEntry() {\n        Entry<K,V> e = next;\n        if (e == null)\n            throw new NoSuchElementException();\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        next = successor(e); //e的直接后继,第一个比e的节点\n        lastReturned = e;\n        return e;\n    }\n\n    final Entry<K,V> prevEntry() {\n        Entry<K,V> e = next;\n        if (e == null)\n            throw new NoSuchElementException();\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        next = predecessor(e);\n        lastReturned = e;\n        return e;\n    }\n\n    public void remove() {\n        if (lastReturned == null)\n            throw new IllegalStateException();\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        // deleted entries are replaced by their successors\n        if (lastReturned.left != null && lastReturned.right != null)\n            next = lastReturned;\n        deleteEntry(lastReturned);\n        expectedModCount = modCount;\n        lastReturned = null;\n    }\n}\n```\n###总结\n1. `TreeMap`实现一种有序的Map类，keys默认是根据`compareTo()`方法(`Comparable`接口)或初始化时指定`Comparator`。所以key元素要么实现了Comparable接口或map制定了Comparator实例。\n2. `TreeMap`内部采用红黑树实现，红黑树是一种二叉查找树，可以保证基本操作(put、get、remove)等复杂度为O(lgn)。红黑树的插入和删除操作比较复杂，可以参考july blog并对照java源码进行阅读。\n3. `TreeMap`同样对应键集合、值集合和键值对集合视图，此外多了一个descendingMap代表逆序map的视图。其集合视图的迭代器，迭代过程实际就是二叉查找树的遍历，首先传入最小的第一个元素，每次next查找当前元素的直接后继节点。\n\n"}