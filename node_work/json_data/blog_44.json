{"text":"**意图**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。\n\n**动机**：有时必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息。\n\n**适用性**\n\n- 抽象出待执行的动作以参数化某对象\n- 在不同的时刻指定、排列和执行请求\n- 支持取消操作\n- 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍\n- 用构建在原语操作上的高层操作构造一个系统\n\n**结构**\n![command pattern](http://img.itc.cn/photo/j3E4MEe9ISV)\n\n**参与者**\n\n- Command：声明执行操作的接口\n- ConcreteCommand：将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现execute\n- Client：创建一个具体命令对象并设定它的接收者\n- Invoker：要求该命令执行这个请求\n- Reciever：知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。\n\n**协作**\n\n- Client创建一个ConcreteCommand对象并指定它的Reciever对象\n- 某Invoker对象存储该ConcreteCommand对象。\n- 该Invoker通过调用Command对象的Execute操作来提交一个请求\n- ConcreteCommand对象对调用它的Reciever的一些操作以执行该请求\n\n**效果**\n\n- Command模式将调用操作的对象与知道如何实现该操作的对象解耦\n- Command是头等的对象。它们可像其他的对象一样被操纵和扩展\n- 你可将多个命令装配成一个复合命令\n- 增加新的Command很容易，因为这无需改变已有的类\n\n**实现**\n\n- 一个命令对象应达到何种智能程度，命令对象的能力可大可小。一个极端是它仅确定一个接收者和执行该请求的动作。另一极端是它自己实现所有功能，根本不需要额外的接收者对象。\n- 支持取消(undo)和重做(redo)，为达到这个目的，ConcreteCommand类可能需要存储额外的状态信息。若只需支持一次取消操作，只需要存储最近一次操作，若需要支持多级，则需要有一个已被执行命令的历史表列 (history list)。\n- 避免取消操作过程中的错误积累。在实现一个可靠的、能保持原先语义的取消 /重做机制时，可能会遇到滞后影响问题。\n\n**应用实例**\n\n- All implementations of `java.lang.Runnable`\n- All implementations of `javax.swing.Action`"}