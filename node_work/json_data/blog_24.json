{"text":"###IO流和分类\n流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。\nIO流分类\n\n- 根据处理数据类型分为：**字节流**、 **字符流**\n- 根据数据流向分为：**输入流**、 **输出流**\n\n字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：\n\n- 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n- 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n###Java IO流对象\n![enter image description here][1]\n\n相关设计模式：\n\n- 适配器模式：`InputStreamReader`和`OutputStreamWriter`将字节流适配为字符流\n- 装饰模式：`FilterInputStream`和`FilterOoutputStream`的子类`BufferedInputStream`等。\n\n|   Basic    |   Byte Based\t|   Byte Based\t|   Character Based\t|   Character Based \t|\n|---\t|---\t|---\t|---\t|---\t|\n|   \t|  InputStream \t|   OutputStream\t| Reader <br/>InputStreamReader \t| Writer<br/>OutputStreamWriter  \t|\n| Arrays|  ByteInputStream \t| ByteOutputStream  | CharArrayReader   | CharArrayWriter  |\n| Files |  FileInputStream \t| FileOutputStream  | FileReader  \t| FileWriter  \t|\n| Pipes |  PipedInputStream | PiepeOutputStream | PipedReader  \t| PipedWrite  \t|\n| Bufferring  | BufferedInputStream   \t| BufferedOutputStream  | BufferedReader| BufferedWriter |\n| Filtering  | FilterInputStream | FilterOutputStream  | FilterReader  \t| FilterWriter  \t|\n| Parsing  \t|  PushbackInputStream<br/>StreamTokenizer \t|   \t| PushbackReader<br/>LineNumberReader  \t|   \t|\n| Strings  \t|   \t|   \t|  StringReader \t| StringWriter  \t|\n| Data  \t| DataInputStream  \t| DataOutputStream  \t|   \t|   \t|\n| Data-Formatted  \t|   \t| PrintStream  \t|   \t|  PrintWriter  \t|\n| Objects \t| ObjectInputStream  \t| ObjectOutputStream  \t|   \t|   \t|\n| Utilities  \t| SequenceInputStream  \t|   \t|   \t|   \t|\n\n\n- 基于数组array的流：字节流是从Byte数组、字符流是从char数组\n- 基于文件File的流：从本地文件读出或写入数据，文件字节流持有`FileDescriptor`对象处理文件打开关闭等操作；文件字节流通过转换流`InputStreamReader`或`OutputStreamWriter`将文件字节流转换为字符流。\n- 基于管道piped的流：向与其它线程共用的管道中读出或写入数据\n- 基于过滤的Filtered相关流：这个流对应的类都是抽象类，提供一些过滤和跳过某些字节或字符的方法\n- 基于缓冲的数据流：继承了Filtered相关类，装饰器提供带缓冲的流读入和写入操作\n- 基于字符串的字符流：`StringReader`和`StringWriter`，数据源是一个字符串\n- 基于Data的字节流：`DataInputStream`和`DataOutputStream`，应用程序可以机器无关的方式从一个流中读取或写入java数据。\n- Data-Formatted的输出流：同样是继承Filter流的装饰器，向其他输出流写入数据，本身内部是带缓冲的，其中`System.out`就是`PrintStream`的实例。\n- 基于Object的字节流：用于序列化和反序列化\n- `SequenceInputStream `将两个或者多个输入流当成一个输入流依次读取\n\n###流的用法\n`PushbackInputStream`于解析InputStream内的数据。有时候你需要提前知道接下来将要读取到的字节内容，才能判断用何种方式进行数据解析。PushBackInputStream允许你这么做，你可以把读取到的字节重新推回到InputStream中，以便再次通过read()读取。\n```\nPushbackInputStream input = new PushbackInputStream(new FileInputStream(\"c:\\\\data\\\\input.txt\"));\nint data = input.read();\ninput.unread(data);\n```\n\n`SequenceInputStream`把一个或者多个InputStream整合起来，形成一个逻辑连贯的输入流。当读取SequenceInputStream时，会先从第一个输入流中读取，完成之后再从第二个输入流读取，以此推类。\n```\nInputStream input1 = new FileInputStream(\"c:\\\\data\\\\file1.txt\");\nInputStream input2 = new FileInputStream(\"c:\\\\data\\\\file2.txt\");\nInputStream combined = new SequenceInputStream(input1, input2);\n```\n\n`PrintStream`允许你把格式化数据写入到底层OutputStream中。比如，写入格式化成文本的int，long以及其他原始数据类型到输出流中，而非它们的字节数据。\n```\nPrintStream output = new PrintStream(outputStream);\noutput.print(true);\noutput.print((int) 123);\noutput.print((float) 123.456);\noutput.printf(Locale.UK, \"Text + data: %1$\", 123);\noutput.close();\n```\n\n`LineNumberReader`是记录了已读取数据行号的BufferedReader。默认情况下，行号从0开始，当LineNumberReader读取到行终止符时，行号会递增(换行\\n，回车\\r，或者换行回车\\n\\r都是行终止符)。\n你可以通过getLineNumber()方法获取当前行号，通过setLineNumber()方法设置当前行数(仅仅改变LineNumberReader内的记录行号的变量值，不会改变当前流的读取位置。流的读取依然是顺序进行，意味着你不能通过setLineNumber()实现流的跳跃读取)\n```\nLineNumberReader reader = new LineNumberReader(new FileReader(\"c:\\\\data\\\\input.txt\"));\nint data = reader.read();\nwhile(data != -1){\n    char dataChar = (char) data;\n    data = reader.read();\n    int lineNumber = reader.getLineNumber();\n}\n```\n\n###参考资料\n[Java IO流学习总结][2]\n[java中的io系统详解][3]\n\n\n  [1]: http://pic002.cnblogs.com/images/2012/384764/2012031413373126.jpg\n  [2]: http://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html\n  [3]: http://blog.csdn.net/ilibaba/article/details/3955799"}