{"text":"###组合模式\n**意图**：将对象组合成树形结构以表示\"部分-整体\"的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。\n**适用性**：\n\n- 你想表示对象的部分-整体层次结构\n- 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象\n\n**结构**：\n![enter image description here][1]\n**参与者**：\n\n- Componet\n  - 为组合中的对象声明接口\n  - 在适当情况下，实现所有类共用接口的缺省行为\n  - 声明一个接口用于访问和管理Componet的子组件\n  - 在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它(可选)\n- Leaf\n  - 在组合中表示叶节点对象，叶节点没有子节点\n  - 在组合中定义图元对象的行为\n- Composite\n  - 定义有子部件的那些部件的行为\n  - 存储子部件\n  - 在Componet接口中实现与子部件有关的操作\n- Client：通过Componet接口操纵组合部件的对象\n\n**协作**：用户使用Componet类接口与组合结构中的对象进行交互。如果接收者是一个叶节点,则直接处理请求。如果接收者是Composite, 它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。\n\n**效果**：\n- 定义了包含基本对象和组合对象的类层次结构\n- 简化客户代码，客户可以一致地使用组合结构和单个对象\n- 使得更容易增加新类型的组件\n- 使你的设计变得更加一般化\n\n**实现**：\n\n-  显式的父部件引用\n  - 保持从子部件到父部件的引用能简化组合结构的遍历和管理，父部件引用可以简化结构的上移和组件的删除。通常在Componet类中定义父部件引用。Leaf和Composite类可以继承这个引用以及管理这个引用的那些操作。\n - 没必要让client维护一个双向的引用关系，通常parent-to-children的引用由client维护，child-to-parent的引用由组合模式本身自动维护。\n- 共享组件：可以减少存储的需求，component必须是无状态的或可共享的状态。但是当一个组件只有一个父部件时，很难共享组件。\n- 最大化Component接口：Composite模式的目的之一是使得用户不知道他们正在使用的具体的Leaf 和Composite类。\n  - Component应为Leaf 和Composite类尽可能多定义一些公共操作，然而有许多操作Component支持但是对于Leaf类可能没有意义，这就违背了接口分离原则ISP\n  - Leaf类中对于无意义的操作，重写为不做任何事情或返回null。\n- 声明管理子部件的操作：管理子部件的操作对于Leaf是没有意义的，因此这些操作应该定义在Component中还是Composite中，这需要在安全性和透明性之间做出权衡。\n - 透明性：定义子部件管理方法在组合层次的根中Component，这样Leaf和Composite具有统一的接口，导致Leaf类中多了add、remove这样没用的接口\n - 安全性：在Composite中定义管理子部件的操作，可以避免Leaf去调用这些操作保证安全性\n- Heavy component和light component：透明方案对应heavy component，定义了所有操作接口；安全方案对应light component只有Leaf和Composite共同的操作。\n- 子部件排序：许多设计指定了Composite的子部件顺序。如果需要考虑子节点的顺序时，必须仔细地设计对子节点的访问和管理接口，以便管理子节点序列。\n- 使用高速缓冲存贮改善性能：如果你需要对组合进行频繁的遍历或查找， Composite类可以缓冲存储对它的子节点进行遍历或查找的相关信息\n - 一个组件发生变化时，它的父部件原先缓冲存贮的信息也变得无效。在组件知道其父部件时，这种方法最为有效。\n - 如果你使用高速缓冲存贮，你需要定义一个接口来通知组合组件它们所缓冲存贮的信息无效\n- 应该由谁删除Component，在没有垃圾回收机制的语言中，当一个Composite被销毁时，通常最好由Composite负责删除其子节点\n- 存贮组件最好用哪一种数据结构：Composite可使用多种数据结构存贮它们的子节点，包括连接列表、树、数组和hash表。数据结构的选择取决于效率\n\n**相关模式**\n\n- Decorator模式通常和Composite模式一起使用，当装饰和组合一起使用时，他们通常常有一个公共的父类。因此装饰必须支持具有Add、Remove和GetChild 操作的Compo nent接口\n- Flyweight让你共享组件，但不能引用他们的父部件\n- Iterator可用于遍历Composite\n- Visitor将本来应该分布在Composite和Leaf类中的操作和行为局部化\n\n###JDK中组合模式实例\n- javax.faces.component.UIComponent#getChildren() (practically all over JSF UI thus)\n- java.awt.Container#add(Component) (practically all over Swing thus)\n![ java.awt.Container][2]\n\n\n  [1]: http://img.itc.cn/photo/jt7A3J42uTt\n  [2]: http://img.itc.cn/photo/jt7NrGLErrn"}