{"text":"###Java反射机制\njava中所有的类型包括基本类型(int, long, float等)以及数组类型都有一个Class对象与之关联，可以通过类名`MyObject.class`或者对象`obj.getClass()`两种方式获取对应类型的class对象。\n此外若编译期间不知道类名，可以通过`Class clazz = Class.forName(\"...\")`方式获得。\n\njava反射机制可以在运行时期检查Java的类信息，包括信息如下：\n\n- 类名：`clazz.getName()` (完整类名) `clazz.getSimpleName()`\n- 修饰符：public,private,static等等的关键字，`int modifiers = clazz.getModifiers();`可以使用java.lang.reflect.Modifier类中的方法来检查修饰符的类型，如`Modifier.isAbstract(int modifiers);`\n- 包信息：`Package package = clazz.getPackage();`\n- 父类信息：`Class superclass = clazz.getSuperclass();`，单继承最多只可能一个父类\n- 实现接口：`Class[] interfaces = clazz.getInterfaces();`，仅仅只返回当前类所实现的接口。当前类的父类如果实现了接口，这些接口是不会在返回的Class集合中的，尽管实际上当前类其实已经实现了父类接口。\n- 构造器：`Constructor[] constructors = clazz.getConstructors();`\n- 方法：`Method[] method = aClass.getMethods();`，返回的Method对象数组包含了指定类中声明为公有的(public)的所有变量集合\n- 成员：`Field[] method = aClass.getFields();`\n- 注解：`Annotation[] annotations = aClass.getAnnotation()`\n\n###Constructor和Method\n**构造函数Constructor**\n```\nConstructor[] constructors = aClass.getConstructors();\n//返回的构造方法的方法参数为String类型\nConstructor constructor = aClass.getConstructor(new Class[]{String.class});\n//构造方法参数\nClass[] parameterTypes = constructor.getParameterTypes();\n//构造方法实例化一个类\nMyObject myObject = (MyObject)constructor.newInstance(\"constructor-arg1\");\n```\n`constructor.newInstance()`方法的方法参数是一个可变参数列表，但是当你调用构造方法的时候你必须提供精确的参数，即形参与实参必须一一对应。\n**方法Method**\n```\nMethod[] methods = aClass.getMethods();//返回所有public方法\n//返回doSomething方法，参数为String\nMethod method = aClass.getMethod(\"doSomething\", new Class[]{String.class});\nMethod method = aClass.getMethod(\"doSomething\", null); //无参方法\nClass[] parameterTypes = method.getParameterTypes();//参数类型\nClass returnType = method.getReturnType();//返回值类型\n//成员方法调用\nObject returnValue = method.invoke(obj, \"parameter-value1\");\n//静态方法调用\nObject returnValue = staticMethod.invoke(null, \"parameter-value1\");\n\n```\n`Method.invoke(Object target, Object … parameters)`方法的第一个参数代表调用的对象若为静态方法传入null，成员方法传入调用该方法的对象实例；第二个参数是一个可变参数列表，必须与方法的形参一一对应。\n\n**私有方法**通过`getDeclaredMethod(String, Class ..)`或`getDeclaredMethods()`获得，调用私有方法method前需要`method.setAccessible(true)`，关闭指定类的Method实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。\n###变量\n```\nField[] fields= aClass.getFields();//所有public字段\nField field = aClass.getField(\"someField\"); \n//变量名称\nString fieldName = field.getName();\n//变量类型\nObject fieldType = field.getType();\n//获取或设置（get/set）变量值, 静态变量不需要传入实例传入null即可\nObject value = field.get(objectInstance);\nfield.set(objetInstance, value);\n```\n**私用变量**通过`getDeclaredField(String)`或`getDeclaredFields()`获得。\n###泛型\njava中泛型信息是在编译期被擦除(erased)，所以运行时候无法获得有关泛型的信息。这种说法并不完全正确。泛型的两种经典用法：\n\n- 声明一个需要被参数化（parameterizable）的类/接口\n- 使用一个参数化类\n\n当你想在运行期参数化类型本身，比如你想检查`java.util.List`类的参数化类型，你是没有办法能知道他具体的参数化类型是什么。**当你检查一个使用了被参数化的类型的变量或者方法，你可以获得这个被参数化类型的具体参数**。\n你不能在运行期获知一个被参数化的类型的具体参数类型是什么，但是你可以在用到这个被参数化类型的方法以及变量中找到他们，换句话说就是获知他们具体的参数化类型。\n\n泛型方法返回类型，泛型方法参数类型和泛型变量类型\n```\npublic class MyClass {\n   public List<String> stringList ;\n\n   public List<String> getStringList(){\n       return this.stringList;\n   }\n   public void setStringList(List<String> list){\n       this.stringList = list;\n   }\n}\n\nvoid printGenericType(genericFieldType ) {\n    if(genericFieldType instanceof ParameterizedType){\n        ParameterizedType aType = (ParameterizedType) genericFieldType;\n        Type[] fieldArgTypes = aType.getActualTypeArguments();\n        for(Type fieldArgType : fieldArgTypes){\n            Class fieldArgClass = (Class) fieldArgType;\n            System.out.println(\"fieldArgClass = \" + fieldArgClass);\n        }\n    }\n}\nMethod method = MyClass.class.getMethod(\"getStringList\", null);\n//泛型方法返回值类型\nType returnType = method.getGenericReturnType();\n//泛型方法参数类型\nType[] genericParameterTypes = method.getGenericParameterTypes();\n\nField field = MyClass.class.getField(\"stringList\");\n//泛型变量类型\nType genericFieldType = field.getGenericType();\n\nprintGenericType(genericFieldType );\n```\n###原始类型和数组\n**原始类型**(int, long, float等)同样有一个Class对象表示相应的类型信息，分别为int.class, long.class等。\n```\nClass intClass1 = Class.forName(\"int\"); //ClassNotFoundException\nClass intClass2 = Class.forName(\"I\"); //ClassNotFoundException\n\npublic Class getClass(String className){\n  if(\"int\" .equals(className)) return int.class;\n  if(\"long\".equals(className)) return long.class;\n   //...\n  return Class.forName(className);\n}\n```\n**数组类型**，java中数组是一种引用类型，其Class对象可以通过`int[].class, Object[].class`方式获得，此外`java.lang.reflect.Array`类方便操作。\n```\nint[] intArray = (int[]) Array.newInstance(int.class, 3);\nArray.set(intArray, 0, 123);\nSystem.out.println(\"intArray[0] = \" + Array.get(intArray, 0));\nClass intArrClass = Class.forName(\"[I\");\n//‘[L’的右边是类名，类名的右边是一个‘;’符号。这个的含义是一个指定类型的数组\nClass stringArrayClass = Class.forName(\"[Ljava.lang.String;\");\n\nClass stringArrayClass = Array.newInstance(String.class, 0).getClass();\nSystem.out.println(\"is array: \" + stringArrayClass.isArray()); //判断是否为数组\n//获取数组的成员类型\nClass stringArrayComponentType = stringArrayClass.getComponentType();\n```\n###注解\n注解是插入代码中的一种注释或者说是元数据。这些信息可以在编译期使用预编译工具进行处理，也可以在运行时使用反射机制进行处理。若想反射时提取注解信息，必须将注解保留期设置为运行`@Retention(RetentionPolicy.RUNTIME)`。\n**类注解、方法注解、参数注解、变量注解**\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface MyAnnotation {\n  public String name();\n  public String value();\n}\n\n@MyAnnotation(name=\"someName\",  value = \"Hello World\")\npublic class TheClass {\n   @MyAnnotation(name=\"someName\",  value = \"Hello World\")\n    public void doSomething(){}\n    public static void doSomethingElse(\n        @MyAnnotation(name=\"aName\", value=\"aValue\") String parameter){\n    }\n   @MyAnnotation(name=\"someName\",  value = \"Hello World\")\n   public String myField = null;\n}\n\nprintAnotation(Annotation annotation ) {\n   if(annotation instanceof MyAnnotation){\n        MyAnnotation myAnnotation = (MyAnnotation) annotation;\n        System.out.println(\"name: \" + myAnnotation.name());\n        System.out.println(\"value: \" + myAnnotation.value());\n    }\n}\n\n//获取类注解\nClass aClass = TheClass.class;\nAnnotation[] annotations = aClass.getAnnotations(); \nAnnotation annotation = aClass.getAnnotation(MyAnnotation.class); \nprintAnotation(annotation );\n\n//获取方法注解\nMethod method = aClass.getMethod(\"doSomething\", null);\nAnnotation annotation = method.getAnnotation(MyAnnotation.class);\nAnnotation[] annotations = method.getDeclaredAnnotations();\n\n//参数注解\nAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\nClass[] parameterTypes = method.getParameterTypes();\nfor(Annotation[] annotations : parameterAnnotations){\n  Class parameterType = parameterTypes[i++];\n  for(Annotation annotation : annotations){\n  }\n}\n\n//变量注解\nField field = aClass .getDeclaredField(\"myField\");\nAnnotation[] annotations = field.getDeclaredAnnotations();\nAnnotation annotation = field.getAnnotation(MyAnnotation.class);\n```\n###参考\n[Java Reflection教程][1]\n\n[1]: http://ifeve.com/java-reflection/"}