{"text":"**意图**：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\n\n**适用性**\n\n- 访问一个聚合对象的内容而无需暴露它的内部表示。\n- 支持对聚合对象的多种遍历。\n- 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。\n\n**结构**\n![enter image description here][1]\n\n**参与者**\n\n- Iterator：迭代器定义访问和遍历元素的接口\n- ConcreteIterator：具体迭代器实现迭代器接口；对该聚合遍历时跟踪当前位置\n- Aggregate：聚合定义创建相应迭代器对象的接口\n- ConcreteAggregate：具体聚合实现创建相应迭代器的接口，该操作返ConcreteIterator的一个适当的实例\n\n**协作**：ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。\n\n**效果**\n\n- 它支持以不同的方式遍历，一个聚合复杂的聚合可用多种方式进行遍历\n- 迭代器简化了聚合的接口\n- 在同一个聚合上可以有多个遍历，每个迭代器保持它自己的遍历状态\n\n**实现**\n\n- 在哪里实现具体迭代器，ConcreteIterator定义为独立的类称为共有迭代器；定义作为Aggregate内部类称为私有迭代器。\n- 谁控制迭代，外部迭代器由客户来控制迭代，内部迭代器由迭代器本身控制\n- 谁定义迭代算法，aggregate能定义迭代算法，迭代器只存储当前状态(称为cursor)；迭代器本身定义迭代算法，容易在同一个聚合上使用不同迭代算法，但是需要访问聚合对象的私有成员。\n- 迭代器的健壮性，当遍历时聚合对象结构发生变化。Copied Iterator一种简单通过拷贝聚合元素实现，开销太大；Robust iterator能够保证聚合对象结构修改操作不好影响正常遍历。FailFast Iterator会抛出一个异常，当迭代过程中发生结构修改时。\n- 空迭代器，一个空迭代器( NullIterator)是一个退化的迭代器, 它有助于处理边界条件。根据定义，一个NullIterator总是已经完成了遍历。\n\n\n**应用实例**\n\n- `java.util.Iterator`接口，ArrayList、LinkedList都提供返回迭代器的接口iterator()，通过内部类实现。\n- `java.util.Enumeration`\n\n\n\n  [1]: http://img.itc.cn/photo/j3F53MuJz4H"}