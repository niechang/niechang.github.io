{"text":"###策略模式\n**意图**：定义一系列的算法 ,把它们一个个封装起来 , 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n\n**动机**：\n\n- 需要换行功能的客户程序如果直接包含换行算法代码的话将会变得复杂，这使得客户程序庞大并且难以维护 , 尤其当其需要支持多种换行算法时问题会更加严重。\n- 不同的时候需要不同的算法，我们不想支持我们并不使用的换行算法\n- 当换行功能是客户程序的一个难以分割的成分时 ,增加新的换行算法或改变现有算法将十分困难\n\n**结构**：\n![Alt text](http://img.itc.cn/photo/j3YJ6LvU6BM)\n\n**参与者**：\n\n- Strategy：定义了所有支持算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算\n- ConcreteStrategy：以Strategy接口实现某具体算法\n- Context：用一个ConcreteStrategy对象来配置；维护一个对Strategy对象的引用；可定义一个接口来让 Strategy访问它的数据。\n\n**协作**：\n\n- Strategy和Context相互作用以实现选定的算法\n- Context将它的客户的请求转发给它的Strategy\n\n**效果**：\n\n- 相关算法系列Strategy类层次为Context定义了一系列的可供重用的算法或行为\n- 一个替代继承的方法 继承提供了另一种支持多种算法或行为的方法。\n- 消除了一些条件语句Strategy模式提供了用条件语句选择所需的行为以外的另一种选择\n- 实现的选择Strategy模式可以提供相同行为的不同实现\n- 客户必须了解不同的Strategy\n- Strategy和Context之间的通信开销\n- 增加了对象的数目Strategy增加了一个应用中的对象的数目\n\n**变化**：\n\n- Context和Strategy之间数据传递：\n - Context通过方法参数进行传递给Strategy：可以解耦但是可能会传递不需要的参数\n - 将Context本身作为参数传递给Strategy：这样两者耦合在一起\n- 使Strategy对象成为可选的\n\n**扩展模式**：\n\n- The Strategy patternis a good example of a pattern for changing the guts\n- The Decorator patternis a good example of a pattern for changing the skin\n![Alt text](http://img.itc.cn/photo/j3YBqzVF1Mk)\n\n\n###JDK中实例\n\n- `java.util.Comparator#compare()`, executed by among others Collections#sort().\n- `javax.servlet.http.HttpServlet`, the service() and all doXXX() methods take HttpServletRequest and HttpServletResponse and the implementor has to process them (and not to get hold of them as instance variables!).\n- `javax.servlet.Filter#doFilter()`\n- Layout Manager in AWT\n![Alt text](http://img.itc.cn/photo/j3YBPouwLFj)\n"}