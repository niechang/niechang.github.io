{"text":"###23. 请不要在新代码中使用原生态类型\n\n- 每个泛型都定义一个原生态类型(raw type)，即不带任何实际类型参数，如`List`。原生态类型会丢失类型安全性。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。\n- 无限制的通配符类型代替原生类型，如`List<?>`。通配符类型是安全的，不能将任何元素(除null之外)放到`List<?>`中。\n- 泛型信息可以在运行时被擦除，在类文字(class literal)中必须使用原生态类型，如`List.class`\n\n###24. 消除非受检警告\n\n- 泛型编程中会遇到许多编译器非受检警告，每条警告都可能产生`ClassCastException`\n- 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个`@SuppressWarnings(\"unchecked\")`注解来禁止这条警告\n- 应该始终尽可能小的范围中使用`SuppressWarnings`注解，永远不用在整个类使用\n\n###25. 列表优先于数组\n数组与泛型的区别\n\n- 数组是协变的(convariant)，泛型则是不可变的(invariant)，实际数组是有缺陷的。\n- 数组是具体化的(refied)，数组会在运行时才知道并检查它们的元素类型约束；泛型只在编译时候强化它们的类型信息，并在运行时丢弃它们的元素类型信息\n- 参数化类型一般都看做是不可具化的类型，即运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具化的参数类型是无限制的统配符类型如`List<?>`\n- 数组和泛型不能很好地混合使用，如`new List<E>[]`、`new List<String>[]`、`new E[]`都是非法的。如果混用得到编译错误或警告，就应该考虑用列表代替数组。\n\n```Java\nObject[] objectArray = new Long[1]; //数组是可协变的，存在缺陷\nobjectArray[0] = \"not fit in\"; //运行时throws ArrayStoreException\nList<Object> o1 = new ArrayList<Long>(); //编译报错\n```\n###26. 优先考虑泛型\n使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。\n```JAVA\npublic class Stack<E> {\n    private E[] elements;\n    \n    public Stack() {\n         @SupressWarning(\"unchecked\")\n          elements = (E[]) new Object[DEAFULT_SIZE]; //E[]是非法的\n     }\n}\n\npublic class Stack<E> {\n    private Object[] elements; //Object[]\n    \n    public E pop() {\n          @SupressWarning(\"unchecked\")\n          E result = elements[--size];\n          return result;\n     }\n}\n```\n###27. 优先考虑泛型方法\n使用泛型方法比要求客户端转换输入参数并返回值得方法更加安全、也更加容易。\n递归类型限制：通过某个包含该类型参数本身的表达式来限制类型参数\n```\npublic static <T extends Comparable<T>>  T max(List<T> list) {}\n```\n###28. 利用有限制通配符来提升API的灵活性\n为了获取最大限度的灵活性，要在表示生成者或者消费者的输入参数上使用通配符类型。\nPECS表示producer-extends, consumer-super\n不要使用通配符类型作为返回类型。\nComparable始终是消费者因此优先`Comparable<? super T>`和`Comparator<? super T>`\n```JAVA\npublic static <T super Comparable<T>> T max(List<T extends Comparable<T>>) {} T \n```\n\n###29. 优先考虑类型安全的异构容器\n类的类型从字面上不是简单Class而是Class<T>，如String.class对应Class<String>。\n```\nMap<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();\n```\n一般泛型用于限制每个容器中只能有固定数目的类型参数，但是可以通过将类型参数放在键上而不是容器上来避开这一限制。\n"}