{"text":"###Map类结构###\nJava的集合类主要由两个接口派生出来，`Collection`和`Map`，上一节我们讨论过`Collection`接口结构，现在来看下`Map`接口。\n\n![java collection](http://img.blog.csdn.net/20141105172256962)\n\n| Class     |Description|\n| :-------- | :--------| \n| HashMap    | 一种存储键/值关联的数据结构，采用**数组和链表**实现  |\n| Hashtable  | 一种用synchronized包裹其内部方法的映射表，保证线程安全  |\n|TreeMap |一种有序排列的映射表，采用**红黑树**实现|\n|EnumMap|一种属于枚举类型的映射表，枚举类型元素集的高效实现，采用**位序列**实现|\n|LinkedHashMap|一种可以记住键/值添加顺序的映射表|\n|WeakHashMap|一种其值无用武之地可以被垃圾回收器回收的映射表|\n|IdentityHashMap|一种用==而不是equals比较键值的映射|\n\n\n###HashMap###\n\n`HashMap`中get和put操作平均是常数时间，元素能平均的映射到每一个桶中。遍历映射表的性能和其容量成正相关，若需要保证遍历的高性能，映射表的初始大小不能太大以及装填因子不能设置太小。\n\n`HashMap`有两个因素影响其性能：初始容量和装填因子，容量指的是映射表中桶的数量，装填因子用于衡量映射表装满的程度。当映射表中元素数量超过装填因子和当前容量的乘积时，映射表将会加倍其容量，并对元素进化重hash操作。\n\n默认装填因子是0.75，能在时间和空间上保持一个较好的平衡。若有大量元素需要加入`HashMap`，初始化一个足够大的映射表来容纳这些元素，其性能比让`HashMap`自动扩容和重哈希效率要高。\n\n`HashMap`的实现是非`synchronized`，其对应同步版本是`Hashtable`，多线程环境下需要保证映射表没有产生并发的结构修改(包括添加和删除元素)，若需要并发修改容器结构，需要保证同步，或者采用`Collections.synchronizedMap(new HashMap(...))`。\n\n###HashMap的实现###\n\n**类定义**\n\n```\npublic class HashMap<K,V>\n\textends AbstractMap<K,V>\n\timplements Map<K,V>, Cloneable, Serializable\n```\n\n**成员**\n\nHashMap实际是一个数组，数组中每个元素都是一个链表。\n```\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; //默认装填因子\n/**\n * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\ntransient int size;\n/**\n * The next size value at which to resize (capacity * load factor).\n */\nint threshold;\nfinal float loadFactor; \n```\n-\t哈希表table，注意其长度必须是2的幂，这和采用hash算法有关系。一般采用取模运算`index = hash_code % size`保证元素在合理范围，但是取模运算效率不高。JDK采用了更快的算法，这个更快的算法源于一个数学规律，size是2的N次方，那么数X对size的模运算结果等价于X和size-1的按位与运算，也就是 `X % size <=> X & (size -1)`。\n- `x & (size-1)`存在一个缺陷其结果只受x的低阶位影响(如size=16只用到低4位bit)，为了避免这个缺陷，在索引位置之前，会重新散列x的bit位，`int hash = hash(key.hashCode()); `\n-\t`threshold`阈值等于`capacity * load factor`，超过阈值时需要加倍扩容并重哈希，注意`loadFactor`声明为final设置以后不能修改。\n\n内部类Entry实际是一个链表，定义如下。\n```\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    final int hash;\n}\n```\n**方法**\n\n构造方法，可以看到数组的大小保证为2的幂且不小于initialCapacity\n```\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    // Find a power of 2 >= initialCapacity\n    int capacity = 1;\n    while (capacity < initialCapacity) //保证capacity为2的幂，且不小于initialCapacity\n        capacity <<= 1;\n\n    this.loadFactor = loadFactor;\n    threshold = (int)(capacity * loadFactor);\n    table = new Entry[capacity];\n    init(); //empty function\n}\n```\nput方法，JDK中没有直接用key的hash code而是再对其进行一次hash计算保证值尽可能分散，通过取模运算找到table中对应的位置，并添加该位置的链表**头部**，若存在相同元素(hash code相等、equals为true)，则直接替换原来值。\n```\npublic V put(K key, V value) {\n    if (key == null)\n        return putForNullKey(value); //key为null元素放在table[0]位置\n    int hash = hash(key.hashCode()); //对key的hash code再进行hash计算\n    int i = indexFor(hash, table.length); //找到table中应当加入的位置[0,length)\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {//替换相同元素\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    addEntry(hash, key, value, i); //都是添加加在头部\n    return null;\n}\n\n static int indexFor(int h, int length) {\n    return h & (length-1); //高效的hash代替h % length\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n\tEntry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n    if (size++ >= threshold)\n        resize(2 * table.length);\n}\n```\n添加元素后size++，并判断是否需要扩容，每次扩容都是原来大小的两倍(扩容后大小同样也是2的幂)。扩容以后元素转移到新的table中，table中每个链表元素实际被逆置了。\n```\t\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n    threshold = (int)(newCapacity * loadFactor);\n}\n\n/**\n * Transfers all entries from current table to newTable.\n */\nvoid transfer(Entry[] newTable) {\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e; //e总是加在头部\n                e = next;\n            } while (e != null);\n        }\n    }\n}\n```\nget方法，其实put方法中也有get的逻辑，先通过hash找到在table中位置，然后再在链表中查找。\n```\npublic V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    int hash = hash(key.hashCode());\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n         e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n            return e.value;\n    }\n    return null;\n}\n```\nremove方法，也是先通过hash找到table中位置，然后在链表中删除相应元素。\n```\npublic V remove(Object key) {\n    Entry<K,V> e = removeEntryForKey(key);\n    return (e == null ? null : e.value);\n}\n\nfinal Entry<K,V> removeEntryForKey(Object key) {\n    int hash = (key == null) ? 0 : hash(key.hashCode());\n    int i = indexFor(hash, table.length);\n    Entry<K,V> prev = table[i]; \n    Entry<K,V> e = prev;\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {\n            modCount++;\n            size--;\n            if (prev == e) //删除链表头\n                table[i] = next;\n            else\n                prev.next = next;\n            e.recordRemoval(this);\n            return e;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return e;\n}\n```\n###HashMap的视图###\n\n集合框架并没有把散列表当作一个集合，`Map`本身是一个顶层接口，不过提供了3个集合类视图：键集合、值集合、键值对集合。分别对应`keySet()`、`values()`、`entrySet()`三个方法的返回值。\n\n在抽象父类`AbstractMap`中定义了键集和值集的引用，由于这些视图是无状态的，没必要每次都重新创建。ketSet方法返回一个内部类`HashMap$KeySet`实例。其本身并没有任何成员和数据结构，都是直接引用外部类的属性和方法来完成相关操作(因此是stateless)。\n```\t\ntransient volatile Set<K>        keySet = null;\ntransient volatile Collection<V> values = null; //define in AbstractMap\nprivate transient Set<Map.Entry<K,V>> entrySet = null; //define in HashMap\n\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    return (ks != null ? ks : (keySet = new KeySet()));\n}\n\nprivate final class KeySet extends AbstractSet<K> {\n    public Iterator<K> iterator() {\n        return newKeyIterator();\n    }\n    public int size() {\n        return size;\n    }\n    public boolean contains(Object o) {\n        return containsKey(o);\n    }\n    public boolean remove(Object o) {\n        return HashMap.this.removeEntryForKey(o) != null;\n    }\n    public void clear() {\n        HashMap.this.clear();\n    }\n}\n```\n**KeySet的迭代器**返回内部类`KeyIterator`实例，其继承自`HashIterator`,实际`HashIterator`实现了整个`Entry`的迭代，首先找到table中第一个不为空的元素，遍历下一个元素的时候，先判断当前位置所在链表有没有后继节点，有的话往后遍历，否则继续到table中找下一个非空元素。实际三个视图的迭代器都是其子类，只是next返回值不同，可能是key、value或entry。\n```\nIterator<K> newKeyIterator()   {\n    return new KeyIterator();\n}\n\nprivate final class KeyIterator extends HashIterator<K> {\n    public K next() {\n        return nextEntry().getKey();\n    }\n}\n\nprivate final class ValueIterator extends HashIterator<V> {\n    public V next() {\n        return nextEntry().value;\n    }\n}\n\nprivate final class EntryIterator extends HashIterator<Map.Entry<K,V>> {\n    public Map.Entry<K,V> next() {\n        return nextEntry();\n    }\n}\n\nprivate abstract class HashIterator<E> implements Iterator<E> {\n    Entry<K,V> next;\t// next entry to return\n    int expectedModCount;\t// For fast-fail\n    int index;\t\t// current slot\n    Entry<K,V> current;\t// current entry\n\n\tHashIterator() {\n        expectedModCount = modCount;\n        if (size > 0) { // advance to first entry\n            Entry[] t = table;\n            while (index < t.length && (next = t[index++]) == null)\n                ;\n        }\n    }\n\n\tpublic final boolean hasNext() {\n        return next != null;\n    }\n\n    final Entry<K,V> nextEntry() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        Entry<K,V> e = next;\n        if (e == null)\n            throw new NoSuchElementException();\n        if ((next = e.next) == null) { //table[index]链表下一个为空\n            Entry[] t = table;\n            while (index < t.length && (next = t[index++]) == null) //table中循环找下一个不为空\n                ;\n        }\n    \tcurrent = e;\n        return e;\n    }\n}\n```\n两位两个视图值集合`values()`和键值对集合`entrySet()`不一一介绍，注意一点值集合是`Collectiont<V>`对象，键值对集合是`Set<Map.Entry<K,V>>`对象。\t\n```\t\nprivate final class Values extends AbstractCollection<V> { \n\t\t... \n}\nprivate final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n \t\t... \n}\n```\n###总结###\n1.\t`HashMap`本身是一个有数组和链表组成的数据结构，其插入和查找元素的消耗可以看成O(1)。默认散列表内部数组大小保证为2的幂次，由于内部采用了位运算代替了传统取模运算来确定元素插入位置。\n2.\t`HashMap`性能由散列表的容量和装填因子两部分决定，其中装填因子默认是0.75，容量默认是16。\n3.\t`Map`是独立接口，并非`Collection`子接口，但是提供三个集合类视图：键集合、值集合、键值对集合。分别对应`keySet()`、`values()`、`entrySet()`三个方法的返回值，这三个集合视图是无状态的，本身依赖`Map`实例本身。遍历元素可以根据需要采用集合类对应的迭代器进行迭代，迭代支持`fail-fast`。\n\n###参考文献###\n- [Java HashMap 分析之三:放入元素](http://blog.csdn.net/csfreebird/article/details/7355282)"}