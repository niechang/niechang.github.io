{"text":"###13. 使类和成员的可访问性最小化\n尽可能的使每个类或成员不被外界访问，对于顶层的(非嵌套)类和接口，只有两种访问权限：包级私有(package-private)和公有的(public)。\n成员(域、方法、嵌套类或嵌套接口)的访问权限包括：\n\n- 私有的(private)：只有在声明该成员的顶层类内部可以访问这个成员\n- 包级私有(package-private)：声明该成员的包内部的任何类都可以访问该成员\n- 受保护的(protected)：该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类可以访问该成员\n- 公有的(public)：任何地方都可以访问该成员\n\n受保护的成员是类的导出API一部分，必须得到支持\n如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超类中的访问级别\n**长度为非零的数组总是可变的**，因此类具有公有的静态final数组域，或者返回这种域的方法总是错误的。修正这个问题可以将该数组设为私有，增加一个公有的不可变列表，或添加一个公有方法返回该数组的副本。\n\n```JAVA\nprivate static final Thing[] PRIVATE_VALUES = { ... };\npublic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));\npublic static final Thing[] values(){\n    return PRIVATE_VALUES.clone();\n} \n```\n###14. 在公有类中使用访问方法而非公有域\n如果类可以在它所在的包外部进行访问，就提供访问方法。\n如果类是包级私有的、或者私有的嵌套类，直接暴露其数据域并没有本质错误。\nJava平台类中反面例子：包括`java.awt.Point`和`java.awt.Dimesion`\n\n###15. 使可变性最小化\nJava平台中的不可变类包括：String、基本类型的包装类、BigInteger、BigDecimal\n使类变成不可变，要遵循的规则：\n\n- 不要提供任何修改该对象状态的方法(称为mutator)\n- 保证类不会被扩展\n- 使所有的域都是final\n- 使所有的域都变称为私有的\n- 确保对于任何可变组件的互斥访问\n\n不可变类的优缺点：\n\n- 不可变对象本质是线程安全的，它们不要求同步。不可变对象可以自由的共享。\n- 不需要也不应该为不可变的类提供clone方法或者拷贝构造器(早期String类中例外，尽量不要使用)\n- 不仅可以共享不可变对象，甚至可以共享它们的内部信息。(BigInteger类使用一个int表示符号，数值用int数组表示，negate方法产生一个新的实例数值相同指向相同数组，符号int相反)\n- 不可变对象为其他对象提供了大量的构建\n- 不可变类的缺点是对于不同的值都需要一个单独的对象。(若需要产生大量不可变对象且不能预测其规模，则可以提供一个配套的可变类，如BigInteger和BitSet、String和StringBuilder)。\n\n###16. 复合优先于继承\n继承打破了封装性，子类依赖于其超类的特定功能实现细节。\n新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这被称为转发，新类中的方法被称为转发方法。\n只有当子类真正是超类的子类型时，才使用用继承。\nJava平台中反面例子：Stack并不是Vector、Properties并不是Hashtable，这些情况下应该使用复合模式而非继承\n\n###17. 要么为继承而设计，并提供文档说明，要么就禁止继承\n被继承的类必须有文档说明它可覆盖的方法的自用性(self-use)。\n类必须通过某种形式提供适当的钩子(hook)，以便能够进入到它的内部工作流程中，这种形式可以使精心选择的受保护方法也可以是受保护的域。\n\n###18. 接口优于抽象类\n抽象类和接口区别：\n\n- 抽象类允许包含某些方法，但是接口则不允许\n- 为了实现抽象类定义的类型，类必须成为抽象类的一个子类\n- 现有的类可以很容易更新，以实现新的接口\n- 接口是定义mixin(混合类型)的理想选择\n- 接口允许我们构造非层次结构的类型框架\n- 抽象类的演变比接口的演变容易得多(Java8中接口通过默认方法进行改善)\n- 接口一旦被公开，并且已被广泛实现，再想改变这个接口几乎不可能\n\n通过对导出的每个重要接口提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的优点结合起来。如Collections Framework中的骨架实现：`AbstractCollection`、`AbstractSet`、`AbstractList`和`AbstractMap`。\n\n###19. 接口只用于定义类型\n当类实现接口时，接口就充当可以引用这个类的实例的类型(type)。\n常量接口：没有任何方法，它只包含静态的final域，每个域都导出一个常量。常量接口模式是对接口的不良使用。因为其暴露了实现细节，实现常量接口，会导致这样实现细节泄露到导出的API中。\nJava平台中常量接口的反面例子：`java.io.ObjectStreamConstants`\n如果需要导出常量可以用以下方法替换：\n\n- 用枚举类型导出这些常量\n- 使用不可实例化的工具类来导出这些常量\n\n###20. 类层次优于标签类\n标签类过于冗长、容易出错，并且效率低下。标签类正是类层次的一种简单仿效。为了将标签类转换为类层次，首先需要为标签类中的每个方法都定义一个包含抽象方法的抽象类，每个方法的行为都依赖标签值。然后，再为每种原始标签定义根类的具体子类。\n类层次可以用来反映类型之间的本质上的层次关系，用于增强灵活性，并进行更好的编译时类型检查。\n\n###21. 用函数对象表示策略\n有些语言支持函数指针、代理、lambda表达式，允许程序调用特殊函数的能力存储起来并传递这种能力。\nJava语言中直到JDK8才支持lambda表达式，之前版本并没有函数指针，但可以用对象引用实现同样的功能。调用对象上的方法通常是执行该对象上的某项操作，如果只有一个方法这样实力称为函数对象。(JDK8中函数接口实例)\n函数对象的主要用途就是实现策略模式。如String类中的`CASE_INSENSITIVE_ORDER`域导出一个不区分大小写的字符串比较器。\n\n###22. 优先考虑静态成员类\n嵌套类是指定义在另一个类的内部的类。嵌套类的目的应该只是为了外围类服务，若可用于其他环境，它就应该是顶层类。\n\n- 静态成员类(static member class)\n- 非静态成员类(nonstatic member class)\n- 匿名类(anonymous class)\n- 局部类(local class)\n\n如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类。由于非静态成员类，每个实例都要包含一个额外执行外围对象的引用，保存这份引用会消耗时间和空间，并且会导致外围实例在符合垃圾回收时仍然得以保留。例如HashMap的实现中，定义了`static class Entry<K,V> implements Map.Entry<K,V>`，由于entry中并没有使用外围类的属性和方法，声明为static。\n\n匿名类的用途：\n\n- 动态的创建函数对象(如Comparator)\n- 创建过程对象(如Runnable、Thread)\n- 用于静态工厂方法内部\n"}