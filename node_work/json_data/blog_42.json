{"text":"**意图**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n**适用性**：\n\n- 一个对象的行为取决于它的状态 , 并且它必须在运行时刻根据状态改变它的行为\n- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态\n\n**结构**\n![enter image description here][1]\n\n**参与者**\n\n- Context：定义客户感兴趣的接口；维护一个ConcreteState子类的实例，这个实例定义当前状态\n- State：定义一个接口以封装与Context的一个特定状态相关的行为\n- ConcrteState：每一子类实现一个与 Context的一个状态相关的行为\n\n**协作**\n\n- Context将与状态相关的请求委托给当前的ConcrteState对象处理\n- Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context\n- Context是客户使用的主要接口\n- Context或ConcrteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换\n\n**效果**\n\n- 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来\n- 它使得状态转换显式化，当一个对象仅以内部数据值来定义当前状态时 , 其状态仅表现为对一些变量的赋值，这不够明确\n- State对象可被共享，如果State对象没有实例变量 ， 即它们表示的状态完全以它们的类型来编码，那么各Context对象可以共享一个State对象\n\n**实现**\n\n- 谁定义状态转换\n - 如果该准则是固定的 , 那么它们可在Context中完全实现\n - 让State子类自身指定它们的后继状态以及何时进行转换 , 通常更灵活更合适\n - 基于表的另一种方法，使用表将输入映射到状态转换\n- 创建和销毁State对象 \n - 仅当需要State对象时才创建它们并随后销毁它们(Lazy)\n - 提前创建它们并且始终不销毁它们(Eager)\n\n**相关模式**\n状态模式和策略模式结构图相同，但是表示具体目的不一样\n状态模式不同状态表现不同的行为；而策略模式是同一个状态有多个不同算法\n\n**具体实例**\n\n- TCP不同状态对应不同的操作\n![enter image description here][2]\n- `javax.faces.lifecycle.LifeCycle#execute()` (controlled by `FacesServlet`, the behaviour is dependent on current phase (state) of JSF lifecycle)\n\n  [1]: http://img.itc.cn/photo/j3n4lbKDHaV\n  [2]: http://img.itc.cn/photo/j3n4lbKDHaV"}