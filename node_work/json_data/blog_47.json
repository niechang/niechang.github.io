{"text":"**意图**：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n**动机**：使用Visitor模式，必须定义两个类层次，一个对应于接受操作的元素；另一个对应于定义对元素的操作的访问者。给访问者类层次增加一个新的子类即可创建一个新的操作。\n\n**适用性**：\n\n- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作\n- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类\n- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作\n\n**结构**\n![](http://img.itc.cn/photo/jXtmmJuA3qX)\n\n**参与者**\n\n- Visitor：为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的那个类。\n- ConcreteVisitor：实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片断乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。\n- Element：定义一个Accept操作，它以一个访问者为参数\n- ConcreteElement：实现Accept操作，该操作以一个访问者为参数\n- ObjectStructure：能枚举它的元素，可以提供一个高层的接口以允许该访问它的元素，可以是一个复合或是一个集合，如一个列表或无序集合\n\n**协作**\n\n- 一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。\n- 当一个元素被访问时，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态\n![](http://img.itc.cn/photo/jXtmZpMbRVW)\n\n**效果**\n\n- 访问者模式使得易于增加新的操作。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。\n- 访问者集中相关的操作而分离无关的操作。相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。\n- 增加新的ConcreteElement类很困难。每添加一个新的ConcreteElement都要在Vistor中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。如果Element类层次是稳定的，而你不断地增加操作获修改算法，访问者模式可以帮助你管理这些改动。\n- 通过类层次进行访问\n- 累积状态。当访问者访问对象结构中的每一个元素时，它可能会累积状态\n- 破坏封装访问者方法假定ConcreteElement接口的功能足够强，足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。"}