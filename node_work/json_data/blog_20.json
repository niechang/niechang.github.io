{"text":"###PriorityQueue\n- `PriorityQueue`是一个基于优先级堆的无边界队列。队列中元素根据自然排序或者根据创建队列时传入的`Comparator`。不允许null值插入，同时不允许插入不可比较的对象。\n- 队列头部是最小的元素，若有多个最小元素，则头部是最小元素中任意一个。poll、remove、peek以及访问元素都是操作队列头部。\n- `PriorityQueue`是没有边界的，但是内部有一个容量参数控制大小。若增加元素超过容量以后，将会自动扩容，具体扩容策略并没有定死。\n- 对于`offer`, `poll`,` remove()`,` add`方法在O(logN)时间完成，`remove(Object)`和`contains(Object)`线性时间，对于检索方法`peek`, `element`, `size`提供常数时间。\n- 返回的迭代器不能够保证按照特定的优先级顺序进行遍历，若需要按照顺序访问可以使用`Arrays.sort(pq.toArray()`。\n- `PriorityQueue`实现是非线程安全的，多线程环境下使用`PriorityBlockingQueue `类。\n\n###PriorityQueue实现\n`PriorityQueue`实际是用堆数据结构来实现，并用数组来表示一个平衡的二元堆，queue[n]的左右孩子分别为`queue[2*n+1]`和`queue[2*(n+1)]`，双亲节点为`queue[(n-1)/2]`最小元素为queue[0]。类的定义和构造函数如下所示。\n```\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable {\n    private transient Object[] queue;\n    private int size = 0;\n    private final Comparator<? super E> comparator;\n    private transient int modCount = 0;\n    \n    public PriorityQueue() {\n        this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n    \n    public PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n    }\n}\n```\n主要方法，`add(E)`和`offer(E)`插入方法在尾部添加，同时要检查是否破会小根堆得特性，父亲节点比儿子节点小，若儿子节点比父节点小，则将新加入孩子节点用父节点值替换并继续向上迭代。\n```\npublic boolean add(E e) {\n    return offer(e);\n}\n\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e); //向上调整\n    return true;\n}\nprivate void siftUp(int k, E x) {\n    if (comparator != null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n}\n\nprivate void siftUpComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>) x;\n    while (k > 0) {\n        int parent = (k - 1) >>> 1; //(k-1)/2\n        Object e = queue[parent];\n        if (key.compareTo((E) e) >= 0) //key > q[parent]没有破坏堆结构\n            break;\n        queue[k] = e; //大元素下移\n        k = parent; //向上继续迭代\n    }\n    queue[k] = key;\n}\n\nprivate void grow(int minCapacity) {\n    if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n    int oldCapacity = queue.length;\n    // Double size if small; else grow by 50%\n    int newCapacity = ((oldCapacity < 64)?\n                       ((oldCapacity + 1) * 2):\n                       ((oldCapacity / 2) * 3));\n    if (newCapacity < 0) // overflow\n        newCapacity = Integer.MAX_VALUE;\n    if (newCapacity < minCapacity)\n        newCapacity = minCapacity;\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n删除元素方法，每次从头部取出最小的元素queue[0]，然后用最后一个元素替换为头部，并从上往下进行调整为堆结构。由于每次取出最小的元素，因此不停poll可以取出有序的元素(堆排序)。\n```\npublic E peek() {\n    if (size == 0)\n        return null;\n    return (E) queue[0];\n}\npublic E remove() {\n    E x = poll();\n    if (x != null)\n        return x;\n    else\n        throw new NoSuchElementException();\n}\npublic E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];\n    E x = (E) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        siftDown(0, x); //从根的位置向下调整\n    return result;\n}\n\nprivate void siftDown(int k, E x) {\n    if (comparator != null)\n        siftDownUsingComparator(k, x);\n    else\n        siftDownComparable(k, x);\n}\nprivate void siftDownComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>)x;\n    int half = size >>> 1;        // loop while a non-leaf\n    while (k < half) {\n        int child = (k << 1) + 1; // assume left child is least\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n            c = queue[child = right]; //右孩子比左孩子小\n        if (key.compareTo((E) c) <= 0) //父节点比孩子节点小直接退出\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = key;\n}\n```\n###迭代器的实现\n迭代器的遍历顺序不能保证是有序的时，实际上再没有调用删除情况下，是按照当前堆数组的顺序进行遍历。注意迭代器中多了一个`ArrayDeque`实例，在删除的时候用于存放一些后面的元素被调到当前之前的内容中，这样可能会导致某些元素没有被遍历，这个数组就是记录这些在删除时被提升到前面的元素。\n\n例如：堆[3,6,4,7,8,5]如图所示，遍历到7的时候，需要删除7，这个时候用最后一个元素5替换7的值，然后删除最后一个元素，发现替换后5比父亲节点6小，向上调整为右图所示结构为[3,5,4,6,8]，由于5所在位置(原来6所在位置)已经遍历过，由于迭代器按照下标访问，所以不记录下来就访问不到了。\n\n![iterator delete](http://img.itc.cn/photo/jtQr61FFz12)\n\n```\n//返回值提供给迭代器用，保证所有元素都被访问\nprivate E removeAt(int i) {\n    assert i >= 0 && i < size;\n    modCount++;\n    int s = --size;\n    if (s == i) // removed last element\n        queue[i] = null;\n    else {\n        E moved = (E) queue[s]; //最后一个元素替换\n        queue[s] = null;\n        siftDown(i, moved);\n        if (queue[i] == moved) {\n            siftUp(i, moved);\n            if (queue[i] != moved)//最后一个元素可能提升到i前面去了，返回这样迭代器可以保存起来\n                return moved;\n        }\n    }\n    return null;\n}\npublic Iterator<E> iterator() {\n    return new Itr();\n}\n\nprivate final class Itr implements Iterator<E> {\n    private int cursor = 0;\n    private int lastRet = -1;\n    //存放那些删除时被提升到前面的(cursor之前)的元素，保证所有元素都被遍历\n    private ArrayDeque<E> forgetMeNot = null;\n    private E lastRetElt = null;\n    private int expectedModCount = modCount;\n    \n    public boolean hasNext() {\n        return cursor < size ||\n            (forgetMeNot != null && !forgetMeNot.isEmpty());\n    }\n    \n    public E next() {\n        if (expectedModCount != modCount)\n            throw new ConcurrentModificationException();\n        if (cursor < size)\n            return (E) queue[lastRet = cursor++];\n        if (forgetMeNot != null) {\n            lastRet = -1;\n            lastRetElt = forgetMeNot.poll();\n            if (lastRetElt != null)\n                return lastRetElt;\n        }\n        throw new NoSuchElementException();\n    }\n\n    public void remove() {\n        if (expectedModCount != modCount)\n            throw new ConcurrentModificationException();\n        if (lastRet != -1) {\n            E moved = PriorityQueue.this.removeAt(lastRet);\n            lastRet = -1;\n            if (moved == null)\n                cursor--;\n            else {\n                if (forgetMeNot == null)\n                    forgetMeNot = new ArrayDeque<E>();\n                forgetMeNot.add(moved);\n            }\n        } else if (lastRetElt != null) {\n            PriorityQueue.this.removeEq(lastRetElt);\n            lastRetElt = null;\n        } else {\n            throw new IllegalStateException();\n    }\n        expectedModCount = modCount;\n    }\n}\n```"}