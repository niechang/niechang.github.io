{"text":"### CopyOnWriteArrayList的实现 ###\n`java.util.concurrent`包中定义常见集合类对应的并发集合类，用于高效处理并发场景，其中`CopyOnWriteArrayList`对应就是`ArrayList`。顾名思义`CopyOnWrite`，写时拷贝，这里写包括对集合类的修改操作，都会创建一个副本。\n**类的定义**\n```\npublic class CopyOnWriteArrayList<E>  \n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable \n```\n可以看到没有继承任何子类，实现接口和`ArrayList`类似。\n\n**关键属性**\n```\n/** The lock protecting all mutators */  \ntransient final ReentrantLock lock = new ReentrantLock();  \n/** The array, accessed only via getArray/setArray. */  \nprivate volatile transient Object[] array;  \n```\n同样是采用数组方式实现，多了一个`volatile`声明，用于保证线程可见性。没有size声明表示实际包含元素的大小，多了一个`ReentrantLock`对象声明。\n\n**常见方法**\n\n构造方法\n```\npublic CopyOnWriteArrayList() {  \n    setArray(new Object[0]); //默认创建一个空数组  \n}  \npublic CopyOnWriteArrayList(Collection<? extends E> c) {  \n    Object[] elements = c.toArray();  \n    // c.toArray might (incorrectly) not return Object[] (see 6260652)  \n    if (elements.getClass() != Object[].class)   //拷贝一份数组\n        elements = Arrays.copyOf(elements, elements.length, Object[].class);  \n    setArray(elements);  \n}  \n```\nsize方法，直接返回数组大小，说明array数组只包含实际大小的空间，get方法，和ArrayList中类似，不过没有index的范围判断\n```\npublic int size() {  \n    return getArray().length;  \n}  \n\npublic E get(int index) {  \n    return (E)(getArray()[index]);  \n}  \n```\n\nadd方法，可以看到无论是在尾部还是指定位置添加，都有锁定和解锁操作，在设置值之前都先将原先数组拷贝一份并扩容至size+1大小。\n\n```\npublic boolean add(E e) {  \n    final ReentrantLock lock = this.lock;  \n    lock.lock(); //锁住  \n    try {  \n        Object[] elements = getArray();  \n        int len = elements.length;  \n\t\t//拷贝array属性，并扩展为length+1大小  \n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;  \n        setArray(newElements);  \n        return true;  \n    } finally {  \n        lock.unlock(); //解锁  \n    }  \n}  \n  \npublic void add(int index, E element) {  \n    final ReentrantLock lock = this.lock;  \n    lock.lock();  \n    try {  \n        Object[] elements = getArray();  \n        int len = elements.length;  \n        if (index > len || index < 0)  \n        throw new IndexOutOfBoundsException(\"Index: \"+index+  \n                            \", Size: \"+len);  \n        Object[] newElements;  \n        int numMoved = len - index;  \n        if (numMoved == 0) //尾部添加  \n            newElements = Arrays.copyOf(elements, len + 1);  \n        else {  \n            newElements = new Object[len + 1];  \n            //elements[0,index) ---> newElements[0,index)  \n            System.arraycopy(elements, 0, newElements, 0, index);  \n            //elements[index,len) --> newElements[index+1,len+1)  \n            System.arraycopy(elements, index, newElements, index + 1,  \n                     numMoved);  \n        }  \n        newElements[index] = element;  \n        setArray(newElements);  \n    } finally {  \n        lock.unlock();  \n    }  \n}  \n```\n\nset方法，ArrayList中set方法直接改变数组中对应的引用，这里需要拷贝数组然后再设置。(else那个分支没看懂，为什么值没有改变还需要设置来保证volatile写语义)\n\n```\npublic E set(int index, E element) {  \n    final ReentrantLock lock = this.lock;  \n    lock.lock();  \n    try {  \n        Object[] elements = getArray();  \n        Object oldValue = elements[index];  \n        if (oldValue != element) {  \n            int len = elements.length;  \n            Object[] newElements = Arrays.copyOf(elements, len);  \n            newElements[index] = element;  \n            setArray(newElements);  \n        } else {  \n            // Not quite a no-op; ensures volatile write semantics  \n            setArray(elements);  \n        }  \n        return (E)oldValue;  \n    } finally {  \n        lock.unlock();  \n    }  \n}  \n```\nremove(int)方法，和指定位置添加类似，需要拷贝[0,index)和[index+1,len)之间的元素\n\n```\npublic E remove(int index) {  \n    final ReentrantLock lock = this.lock;  \n    lock.lock();  \n    try {  \n        Object[] elements = getArray();  \n        int len = elements.length;  \n        Object oldValue = elements[index];  \n        int numMoved = len - index - 1;nt  \n        if (numMoved == 0) //删除最后一个元素  \n            setArray(Arrays.copyOf(elements, len - 1));  \n        else {  \n            Object[] newElements = new Object[len - 1];  \n            //elements[0,index) --> newElements[0,index)  \n            System.arraycopy(elements, 0, newElements, 0, index);  \n            //elements[index+1,len) --> newElements[index,len-1)  \n            System.arraycopy(elements, index + 1, newElements, index,  \n                     numMoved);  \n            setArray(newElements);  \n        }  \n        return (E)oldValue;  \n    } finally {  \n        lock.unlock();  \n    }  \n}  \n```\nremove(Object)方法，分配一个len-1大小的新数组，遍历原来数组，如果找到则将原来数组以后的元素拷贝到新数组中并将list设置为新数组，否则直接给新数组赋值上原来数组。\n```\npublic boolean remove(Object o) {  \n    final ReentrantLock lock = this.lock;  \n    lock.lock();  \n    try {  \n        Object[] elements = getArray();  \n        int len = elements.length;  \n        if (len != 0) {  \n        // Copy while searching for element to remove  \n        // This wins in the normal case of element being present  \n        int newlen = len - 1;  \n        Object[] newElements = new Object[newlen];  \n  \n        for (int i = 0; i < newlen; ++i) {  \n            if (eq(o, elements[i])) {  \n            // found one;  copy remaining and exit  \n            for (int k = i + 1; k < len; ++k)  \n                newElements[k-1] = elements[k];  \n            setArray(newElements);  \n            return true;  \n            } else  \n            newElements[i] = elements[i];  \n        }  \n  \n        // special handling for last cell  \n        if (eq(o, elements[newlen])) {  \n            setArray(newElements);  \n            return true;  \n        }  \n        }  \n        return false;  \n    } finally {  \n        lock.unlock();  \n    }  \n }  \n```\n### 迭代器的实现 ###\n\n`ArrayList`中迭代器支持`fast fail`，一旦检测到遍历过程中发送了修改则会抛出`ConcurrentModificationException`；`CopyOnWriteArrayList`的迭代器由于修改的时候都会重新copy一份数组，因此不存在并发修改问题，也不会抛出`ConcurrentModificationException`。同样支持单向和双向迭代器，其iterator和listIterator方法都是通过内部类`COWIterator`创建，只是前者返回接口限定为单向迭代`Iterator<E>`。\n\n**COWIterator定义**\n```\t\n/** Snapshot of the array **/  \nprivate final Object[] snapshot;  \n/** Index of element to be returned by subsequent call to next.  */  \nprivate int cursor;  \n```\n构造器\n```\nprivate COWIterator(Object[] elements, int initialCursor) {  \n    cursor = initialCursor;  \n    snapshot = elements;  \n}  \n```\niterator和listIterator中会传递当前数组的引用和cursor(无参方法为0，有参数方法为对应值)\n\n**常见方法**\n```\npublic boolean hasNext() {  \n    return cursor < snapshot.length;  \n}  \npublic boolean hasPrevious() {  \n    return cursor > 0;  \n}  \npublic E next() {  \n    if (! hasNext())  \n        throw new NoSuchElementException();  \n    return (E) snapshot[cursor++];  \n}  \npublic E previous() {  \n    if (! hasPrevious())  \n        throw new NoSuchElementException();  \n    return (E) snapshot[--cursor];  \n}  \t\n```\n另外其他add、remove和set修改容器的方法都没有实现，直接`throw new UnsupportedOperationException()`;\n\n### 总结 ###\n\n1. `CopyOnWriteArrayList`的迭代器保留一个执行底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于基础数组不会被修改(修改都是复制一个新的数组)，因此对其同步只需要保证数组内容的可见性。多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程互相干扰。不会抛出`CocurrentModificationException`，并且返回元素与创建迭代器创建时的元素完全一致，不必考虑之后修改操作带来影响。\n2. 每次修改容器都会复制底层数组，这需要一定开销，特别是容器规模较大。仅当迭代操作远远多于修改操作时，才应该使用`CopyOnWriteArrayList`。"}