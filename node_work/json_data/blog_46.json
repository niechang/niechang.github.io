{"text":"**意图**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n**动机**：有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来，需要实现检查点和取消机制 , 而要实现这些机制，你必须事先将状态信息保存在某处，这样才能将对象恢复到它们先前的状态。\n\n**适用性**\n\n- 必须保存一个对象在某一个时刻的 (部分 )状态，这样以后需要时它才能恢复到先前的状态\n- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性\n\n**结构**\n![Memento](http://img.itc.cn/photo/jXlfqatnrlG)\n\n**参与者**\n\n- Memento备忘录\n - 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态\n - 防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者(caretaker)只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。\n- Originator原生器\n - 原发器创建一个备忘录，用以记录当前时刻它的内部状态\n - 使用备忘录恢复内部状态\n- Caretaker负责人\n - 负责保存好备忘录\n - 不能对备忘录的内容进行操作或检查\n\n**协作**\n\n- 管理器向原发器请求一个备忘录，保留一段时间后，将其送回给原发器。有时管理者不会将备忘录返回给原发器 , 因为原发器可能根本不需要退到先前的状态。\n- 备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。\n\n**效果**\n \n- 保持封装边界 使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息\n- 它简化了原发器在其他的保持封装性的设计中，Originator负责保持客户请求过的内部状态版本\n- 使用备忘录可能代价很高，如果原发器在生成备忘录时必须拷贝并存储大量的信息，或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销\n- 定义窄接口和宽接口，在一些语言中可能难以保证只有原发器可访问备忘录的状态\n- 维护备忘录的潜在代价，管理器负责删除它所维护的备忘录\n"}