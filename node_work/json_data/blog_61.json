{"text":"###57. 只针对异常的情况才使用异常\n设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常\n\n###58. 对可恢复的情况使用受检查异常，对编程错误使用运行时异常\n- Java程序提供3种可抛出结构：受检查异常、运行时异常、错误\n- 如果期望调用者能够适当的恢复，对于这种情况就应该使用受检查异常\n- 运行时异常和错误都是不需要也不应该被捕获的可抛出结构\n\n###59. 避免不必要的使用受检的异常\n\n###60. 优先使用标准的异常\n|异常|使用场合|\n|---|---|\n|IllegalArgumentException|非null的参数值不正确|\n|IllegalStateException|对于方法调用而言，对象状态不合适|\n|NullPointerException|在禁止使用null情况下参数值为null|\n|IndexOutOfBoundsException|下标参数值越界|\n|ConcurrentModificationException|在禁止并发修改的情况下，检测到对象的并发修改|\n|UnsupportedOperationException|对象不支持用户请求的方法|\n\n###61. 抛出与抽象相对应的异常\n更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法称为异常转译。\n```JAVA\npublic E get(int index) {\n    ListIterator<E> i = listIterator(index);\n    try {\n          return i.next();\n     }catch(NoSuchElementException e) {\n          throw new IndexOutOfBoundsException(\"Index: \" + index);\n     }\n}\n```\n\n###62. 每个方法抛出的异常都要有文档\n- 始终要单独的声明受检的异常，并且利用Javadoc的@throws标记，准确的记录下抛出每个异常的条件\n- 永远不要声明一个方法throws Exception或throws Throwable\n- 使用Javadoc的@throws标签记录下一个方法可能抛出的每个未受检异常，但是不要使用throws关键字将未受检的异常包含在方法的声明中\n\n###63. 在细节消息中包含能捕获失败的信息\n为了捕获失败、异常的细节消息应该包含所有\"对该异常有贡献\"的参数和域的值\n\n###64. 努力使失败保持原子性\n一般而言，失败的方法调用应该使对象保持在被调用之前的状态(失败原子性)，实现失败原子性的途径\n\n- 设计一个不可变对象\n- 对于可变对象，在执行操作前检查参数的有效性\n- 编写一段恢复代码\n- 在对象的一份临时拷贝上执行操作\n\n###65. 不要忽略异常\n空的catch块会使异常达不到应有的目的"}