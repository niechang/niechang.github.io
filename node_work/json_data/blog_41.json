{"text":"**意图**：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n**适用性**：\n\n- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定\n- 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n- 可处理一个请求的对象集合应被动态指定\n\n**结构**\n![enter image description here][1]\n![enter image description here][2]\n\n**参与者**\n\n- Handler：定义一个处理请求的接口；实现后继链(可选)\n- ConcreteHandler：处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理之；否则将该请求转发给它的后继者\n- Client：向链上的具体处理者 ( ConcreteHandler )对象提交请求\n\n**协作**\n当客户提交一个请求时，请求沿链传递直至有一个 ConcreteHandler 对象负责处理它\n\n**效果**\n\n- 降低耦合度，该模式使得一个对象无需知道是其他哪一个对象处理其请求\n- 增强了给对象指派职责 ( Responsibility )的灵活性 当在对象中分派职责时，职责链给你更多的灵活性\n- 不保证被接受，既然一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理\n\n**应用实例**\n\n- DOM(Document Object Model)中的事件处理模型，例如IE中采用冒泡模型，从底向 上处理事件，也可以阻止冒泡(e.cancelBubble = true)。\n- `javax.servlet.Filter#doFilter()`\n- `java.util.logging.Logger#log()`\n\n\n  [1]: http://img.itc.cn/photo/j3nDPkki0i4\n  [2]: http://img.itc.cn/photo/j3nZRMAuz3g"}