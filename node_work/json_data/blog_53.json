{"text":"###1. 简单动态字符串\nRedis数据库中每个键值对都是由对象组成的，其中\n- 数据库键总是一个字符串对象\n- 数据库键的值可以是字符串对象、列表对象(list object)、哈希对象(hash object)、集合对象(set object)、有序集合对象(sorted set object)\n\nRedis中没有使用C语言传统字符串表示(以空字符结尾的字符数组)，而是使用一种简单动态字符串(simple dynamic string, SDS)的抽象类型。\n\n**SDS的定义**\n```C\nstruct sdshdr{\n    int len; //记录buf数组已使用字节的数量\n    int free; //记录buf中未使用字节的数量\n    char buf[];//字节数组，用于保存字符串\n}\n```\n\n**SDS与C字符串的区别**\n\n- 常数时间复杂度获取字符串长度\n- 字符串连接等操作没有缓冲区溢出\n- 减少修改字符串时带来的内存重分配次数\n- 如果对SDS进行修改之后，SDS的长度(len)小于1MB，那么程序分配和len属性相同的大小的未使用空间free，此时len属性的值和free的属性值相同\n- 如果对SDS进行修改之后，SDS的长度大于等于1MB，那么程序将会分配1MB的未使用空间。\n- 惰性空间释放：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性记录这些字节，等等将来使用。\n- 二进制安全，所以SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。\n- 兼容部分C字符串函数如`strcat(c_string, sds->buf)`\n\n###2. 链表\n链表提供高效的节点重排能力，以及排序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。Redis中列表键的底层实现之一就是链表。\n\n实现`addlist.h/listNode`和`addList.h/list`\n```C\ntypedef struct listNode {\n    struct listNode *pre;\n    struct listNode *next;\n    void *value;//节点的值\n} listNode;\n\ntypdef struct list {\n    listNode *head;\n    listNode *tail;\n    unsigned long len;\n    void *(*dup) (void *ptr);//节点复制函数\n    void (*free) (void *ptr);//节点值释放函数\n    int (*match) (void *ptr, void *key); //节点值对比函数\n} list;\n```\nRedis中链表特性如下：\n\n- 双端：链表节点带有prev和next指针，获取某个节点前置和后置节点的复杂度都是O(1)\n- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表访问以NULL为终点\n- 带表头指针和表尾指针(head和tail)\n- 带链表长度计数器，获取链表节点数量复杂度为O(1)\n- 多态：链表节点使用void*指针保存节点值，可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，链表可以用于保存各种不同类型的值。\n\n###3. 字典\n字典又称作符号表(symbol table)、关联数组(associative array)或者映射(map)，是一种用于保存键值对的抽象数据结构。\n字典相关命令：\n```\nSET msg \"hello world\" //设置键值对map\nHLEN website //获取映射表的长度\nHGETALL website //获得映射表所有元素集合\n```\n**实现** 由`dict.h/dictht`\n```C\ntypedef struct dictht{\n    dictEntry **table; //哈希表数组\n    unsigned long size; //哈希表大小\n    unsigned long sizemask; //哈希表大小掩码, size-1\n    unsigned long used; //该哈希表已用节点数\n} dictht;\n//哈希表节点\ntypedef struct dictEntry {\n    void *key;\n    union{\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n//redis中字典由`dict.h/dict`定义\ntypedef struct dict {\n    dictType *type; //类型特定函数\n    void *private; //私有数据\n    dictht ht[2]; //哈希表\n    int trehashidx;\n}dict;\n\ntypedef struct dictType {\n    unsigned int (*hashFunction) (const void *key); //计算哈希值的函数\n    void *(*keyDup)(void *privdata, const void *key);//复制键的函数\n    void *(*valDup)(void *privdata, const void *obj);//复制值的函数\n    int (*keyCompare) (void *privdata, const void *key1, const void* key2);//对比键的函数\n    void (*keyDestructor)(void *privdata, void *key);//销毁键的函数\n    void (*valDestructor)(void *privdata, void *obj);//销毁值的函数\n}\n```\nkey用于保存键，而v属性则保存着键值对中的值，其中值可以是一个指针，或者是一个uint64_t整数或int64_t整数，next指向下一个节点的指针用于解决键冲突。\n\n`dict`结构体中成员说明：\n\n- type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数\n- privdata属性则保存了需要传给那些类型特定函数的可选参数\n- ht属性包含两个指向哈希表的数组，字典时候使用ht[0]，ht[1]只会在rehash的时候使用\n\n**哈希算法**\nRedis计算哈希值和数组对应的索引值的过程如下\n```C\nhash = dict->type->hashFunction(key)\nindex = hash & dict->ht[x].sizemask; //x可以是0或1\n```\n当字典被用作数据库底层实现，或者哈希键的底层实现时，Redis使用`MurmurHash2`算法来计算哈希值。\n解决键冲突：Redis的哈希表使用链地址法来解决键冲突\n\n**rehash**\n当哈希表的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者压缩，Redis对字典的哈希表rehash步骤如下：\n\n(1) 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作以及ht[0]当前包含的键值对数量(ht[0].used)\n(2) 将保存在ht[0]中的所有键值对rehash到ht[1]上面，rehash指的是重新计算键的哈希值和索引值\n(3) 当ht[0]包含的所有键值对都迁移到ht[1]后，释放ht[0]空间，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表\n扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但rehash操作不是一次性、集中式完成的，而是分多次、渐进式的完成。进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，因此字典的删除、查找、更新等操作会在两个哈希表上进行，但是插入操作的键值对一律保存到ht[1]中。\n\n###4. 跳跃表\n跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\n\n**实现**\n```C\ntypedef struct zskiplistNode {\n    struct zskiplistLevel {\n        struct zskiplistNode *forward; //前进指针\n        unsigned int span;//跨度\n    } level[];\n    struct zskiplistNode *backward;\n    double score; //分值\n    robj *obj;//成员对象\n}\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length; //表中节点的数量\n    int level; //表中层数最大的节点层数\n} zskiplist;\n```\n\n- 层，跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层的来加快访问其他节点的速度。每次创建一个新跳跃表节点时，程序根据幂次定律随机生成一个1~32之间的值作为level数组的大小，表示层的高度。\n- 前进指针，每个层都有一个指向表尾方向的指针(level[i].forward)，用于从表头向表尾方向访问节点。\n- 跨度，层的跨度用于记录两个节点之间的距离，跨度是用来计算排位(rank)\n- 后退指针用于从表尾向表头方向访问节点，一次只能后退至前一个节点\n- 分值和成员，节点的分值是一个double类型，跳跃表中的所有节点都按分值从小到大来排序。节点的成员对象obj是一个指针，指向一个字符串对象SDS。同一个跳跃表中各个节点保存成员对象必须是唯一的，但是多个节点保存的分值却可以相同：分值相同的节点将按照成员对象在字典中的大小进行排序，成员对象较小的节点会排在前面。 \n\n###5. 整数集合\n整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。\n```C\ntypedef struct intset {\n    uint32_t encoding;//编码方式\n    uint32_t length;//集合元素的数量\n    int8_t contents[];//保存元素的数组\n} intset;\n```\ncontents数组是整数集合底层实现，其每个元素都是数组一个项，各个项在数组中按值的大小从小到大有序的排列，并且数组中不包含任何重复项。虽然数组声明为int8_t，但是实际保存的类型取决于encoding属性的值。\n\n- 若encoding属性的值为INTSET_ENC_INT16，那么contents就是int16_t类型数组\n- 若encoding属性的值为INTSET_ENC_INT32，那么contents就是int32_t类型数组\n- 若encoding属性的值为INTSET_ENC_INT64，那么contents就是int64_t类型数组\n\n**升级**\n新加入的元素类型比整数集合现有所有元素的类型都要长时，整数集合需要 进行升级。\n\n- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间\n- 将底层数组现有的所有元素都转换成域新元素相同的类型，并将类型转换后的元素放置到正确的位置\n- 将新元素添加到底层数组(引发升级的新元素要不比所有元素小要么大，所以新元素位置为0或者length-1)\n\n整数集合不支持降级操作。\n\n###6. 压缩列表\n压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis会采用压缩列表来做列表键的底层实现。\n```\n//列表键包含小整数和短字符串\nRPUSH ls 1 3 5 10086 \"hello\" \"world\"\n//哈希键包含少量键值对，且每个键值对是小整数或短字符串\nHMSET profile \"name\" \"Jack\" \"age\" 28 \"job\" \"Programmer\" \n```\n\n\n| 属性 | 类型 | 长度 | 用途 |\n|---|---|---|---|\n|zlbytes|uint32_t|4B|记录整个压缩列表占用的内存字节数：内存重分配或计算zlend的位置时使用|\n|zltail|uint32_t|4B|记录压缩列表尾节点距离起始地址有多少字节，无需遍历获得表尾节点地址|\n|zllen|uint16_t|2B|记录压缩列表包含的节点数量：当小于UINT16_MAX时为真实值，大于该值时需要遍历压缩列表获得真实长度|\n|entryX|列表节点|不定|压缩列表的各个节点，节点长度由节点保存内容决定|\n|zlend|uint8_t|1B|特殊值0xFF，用于标记压缩列表的末端|\n\n**压缩列表节点的构成**：previous_entry_length、encoding、content\n\n- previous_entry_length以字节为单位，记录了压缩列表前一个节点的长度，该属性可以是1B或5B\n - 若前一节点的长度小于254B，那么previous_entry_length属性的长度为1B\n - 若前一节点的长度大于等于254B，那么previous_entry_length属性的长度为5B，其中第一字节设置为0xFE，之后4字节保存前一节点的长度。\n- encoding属性记录节点content属性所保存的类型以及长度\n - 1字节、2字节、5字节长，值的最高位为00、01或10的是字节数组的编码：表示content属性保存着字节数组，数组长度由编码除去最高两位之后的其他位记录。\n - 1字节长，值的最高位以11开头是整数编码：表示content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。\n- content属性负责保存节点的值，可以是整数值或者字节数组\n\n添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现几率并不高。\n"}