{"text":"###ArrayDeque和Deque接口\n- `ArrayDeque`是一种可变数组实现`Deque`接口的类，其中`Deque`缩写为\"Double end queue\"，代表一个双端队列，可以在队列两头插入或删除元素。`ArrayDeque`没有容量限制，空间可以动态增长。  \n- 不允许Null元素的插入，`ArrayDeque`可以用作statck且其性能比`Stack`更高，也可以用作queue且比`LinkedList`速度更快。\n- 大部分`ArrayDeque`操作为常数时间，除了remove, removeFirstOccurrence, contains, iterator.remove(), 和批量操作方法，所有这些操作在线性时间内完成。\n- `ArrayDeque`本身不是线性安全，返回的迭代器支持`fail-fast`，迭代过程若检测到对容器结构进行修改，将会抛出并发修改异常。\n\n下图是`Queue`接口的在集合类中的层次结构，可以看到主要有`PriorityQueue`优先队列和`ArrayDeque`两个类，此外`LinkedList`同时实现了`List`和`Deque`接口，`Vector`和`Stack`这两个都是同步容器实现了`List`接口，性能比较低一般都不用`Stack`一般用`ArrayDeque`替换，`Vector`用`ArrayList`替换。   \n![Queue](http://img.itc.cn/photo/jti0TvJnoQb)\n\n###ArrayDeque的实现\n类的定义，实际是一个数组实现的顺序队列，包含一个数组空间和头(head)尾(tail)两个指针，当头尾指针相等`head == tail`的时候队列为空，多出一个空间由于区分队列是否满了还是为空，队列满的情况为`(tail+1)%SIZE == head`，队列实际大小为`(tail-head+SIZE)%SIZE`。\n\n```java\npublic class ArrayDeque<E> extends AbstractCollection<E>\n                           implements Deque<E>, Cloneable, Serializable {\n    //存放元素的数组，长度为2的n次幂，这个数组不允满\n    private transient E[] elements;\n    \n    //队列头部(remove(), pop()删除元素指示的位置)\n    private transient int head;\n    \n    //队列尾部，元素加入的位置(addLast(E), add(E), push(E))\n    private transient int tail;\n    \n    private static final int MIN_INITIAL_CAPACITY = 8;\n    \n    public boolean isEmpty() {\n        return head == tail;\n    }\n    \n    //由于数组大小为2的幂，用&运算代替取模(X % size <=> X & (size -1))\n    public int size() {\n        return (tail - head) & (elements.length - 1);\n    }\n    \n    public boolean add(E e) {\n        addLast(e);\n        return true;\n    }\n    \n    public void addLast(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        elements[tail] = e; //tail表示当前插入位置，插入以后加1并判断队列是否满\n        if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n            doubleCapacity();\n    }\n    \n    private void doubleCapacity() {\n        assert head == tail;\n        int p = head;\n        int n = elements.length;\n        int r = n - p; // number of elements to the right of p\n        int newCapacity = n << 1;\n        if (newCapacity < 0)\n            throw new IllegalStateException(\"Sorry, deque too big\");\n        Object[] a = new Object[newCapacity];\n        System.arraycopy(elements, p, a, 0, r); //elements[p,n) --->a[0,r)\n        System.arraycopy(elements, 0, a, r, p); //elements[0,p) ---> a[r,n)\n        elements = (E[])a;\n        head = 0;\n        tail = n;\n    }\n    \n    public E remove() {\n        return removeFirst();\n    }\n    \n    public E removeFirst() {\n        E x = pollFirst();\n        if (x == null)\n            throw new NoSuchElementException();\n        return x;\n    }\n    \n    public E pollFirst() {\n        int h = head;\n        E result = elements[h]; // Element is null if deque empty\n        if (result == null)\n            return null;\n        elements[h] = null;     // Must null out slot\n        head = (h + 1) & (elements.length - 1);\n        return result;\n    }\n}\n```"}