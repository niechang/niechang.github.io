{"text":"###外观模式\n**意图**：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n**动机**：将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一是就是引入一个外观facade对象，它为子系统中较一般的设施提供了一个单一而简单的界面。\n**适用性**：\n\n- 当你要为一个复杂子系统提供一个简单接口时\n- 客户程序与抽象类的实现部分之间存在着很大的依赖性\n- 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。\n\n**结构**：\n![Alt text](http://img.itc.cn/photo/jtqrkNDdgJ1)\n\n**参与者**：\n- Facade：知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象\n- Subsystem classes：实现子系统的功能；处理由Facade对象指派的任务；没有facade的任何相关信息；即没有指向facade的指针\n\n**协作**：\n- 客户程序通过发送请求给Facade的方式与子系统通讯， Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。\n- 使用Facade的客户程序不需要直接访问子系统对象\n\n**效果**\n\n- 它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。\n- 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的\n- 如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。\n\n**实现注意细节**：\n\n- 降低客户-子系统之间的耦合度。用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度\n- 公共子系统类与私有子系统类。一个子系统与一个类的相似之处是，它们都有接口并且它们都封装了一些东西—类封装了状态和操作，而子系统封装了一些类\n\n###JDK中Facade实例\n\n- `javax.faces.context.FacesContext`, it internally uses among others the abstract/interface types `LifeCycle`, `ViewHandler`, `NavigationHandler` and many more without that the enduser has to worry about it (which are however overrideable by injection).\n- `javax.faces.context.ExternalContext`, which internally uses `ServletContext`, `HttpSession`, `HttpServletRequest`, `HttpServletResponse`, etc.\n"}