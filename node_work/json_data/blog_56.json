{"text":"###RDB命令和实现\nRDB持久化生成一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时数据库的状态。\n\n**RDB文件生成的命令和载入**\n\n- `SAVE`命令会阻塞Redis服务器进程，直到RDB文件创建完毕\n- `BGSAVE`命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器(父)进程继续处理命令请求。\n- RDB文件载入工作是在服务器启动时自动执行；由于AOF文件的更新频率比RDB文件频繁，如果开启了AOF持久化功能，则优先使用AOF文件还原数据库\n- `BGSAVE`和`BGREWRITEAOF`命令不能同时执行\n    - 如果`BGSAVE`正在执行，那么客户端发送的`BGREWRITEAOF`命令会被延迟到`BGSAVE`执行之后\n    - 如果`BGREWRITEAOF`正在执行，那么客户端发送的`BGSAVE`会被服务器拒绝\n\n**自动间隔性保存**\n\nRedis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次`BGSAVE`命令。\n```\nsave 900 1   //服务器在900秒之内，对数据库进行了至少1次修改\nsave 300 10\nsave 60 1000\n```\nsave选项的保存条件存储在redisServer结构saveparams属性，此外还维护了dirty计数用于距离上一次执行SAVE或BGSAVE命令之后，服务器对数据库进行多少次修改；lastsave属性是一个UNIX时间戳，记录上一次SAVE或BGSAVE命令的时间。\n\n```\nstruct redisServer {\n    struct saveparam *saveparams;\n    long long dirty; //修改计数器\n    time_t     lastsave; //上一次执行保存的时间\n};\nstruct saveparam {\n    time_t seconds; //秒数\n    int     changes; //修改数\n};\n```\n\n**检查保存条件是否满足**\nRedis的服务器周期性操作函数`serverCron`默认每隔100毫秒就会执行一次，检查save选项中的条件是否满足，若满足的话则执行BGSAVE命令。\n\n###RDB文件结构\n![RDB文件结构](http://img.itc.cn/photo/jmNqhgcMyZM)\n\n- RDB文件包括REDIS(5B常量)、db_version(4B字符串表示的整数)、databases、EOF(1B表示文件正文内容的结束)、check_sum(8B无符号整数)\n- database部分由SELECTDB(1B常量表示接下来是一个数据库号码)、db_number(保存数据库号码)、key_value_pairs(所有键值对数据和过期时间)\n- key_value_pairs部分TYPE记录了value的类型，key总是一个字符串对象，EXPIRETIME_MS常量1B表示接下来是时间戳、ms是8B带符号整数记录以毫秒为单位时间戳\n\n**value的编码**\n\n- 字符串对象，对应TYPE为`REDIS_RDB_TYPE_STRING`\n    - 字符串对象可以用8位来保存的整数，直接保存整数\n    - 字符串长度小于等于20B，直接保存字符串\n    - 字符串长度大于20B，字符串会被压缩后再保存，LZF算法\n- 列表对象，对应`REDIS_RDB_TYPE_LIST`，value保存的是`REDIS_ENCODING_LINKEDLIST`，list_length记录列表长度，列表的元素用字符方式保存\n- 集合对象，对应`REDIS_RDB_TYPE_SET`，value保存的是`REDIS_ENCODING_HT`，set_size记录集合大小，集合元素用字符串方式保存\n- 哈希表对象，对应`REDIS_RDB_TYPE_HASH`，value保存的是`REDIS_ENCODING_HT`编码， hash_size记录大小，键和值用字符串方式保存\n- 有序集合对象，对应`REDIS_RDB_TYPE_ZSET`，value保存的是`REDIS_ENCODING_SKIPLIST`编码的有序集合对象\n- INTSET编码的集合，对应TYPE为`REDIS_TDB_TYPE_SET_INTSET`，那么value保存的是一个整数集合，先将整数集合转换为字符串对象然后再保存\n- ZIPLIST编码的列表、哈希表、或有序集合，对应TYPE值为`REDIS_TDB_TYPE_LIST_ZIPLIST`、`REDIS_TDB_TYPE_HASH_ZIPLIST`、`REDIS_TDB_TYPE_ZSET_ZIPLIST`则value保存的是压缩列表。将压缩列表转换为字符串再保存字符串对象\n\n分析RDB文件的命令：`od -cx dump.rdb` (-c表示ASCII编码方式，-x表示十六进制方式)\n\n\n###AOF文件写入和载入\nAOF(Append Only File)持久化通过保存Redis服务器所执行的命令来记录数据库状态\nAOF持久化实现分为命令追加、文件写入、文件同步三个步骤：\n\n- 命令追加：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的命令追加到服务器状态的aof_buf缓冲区末尾\n- AOF文件写入与同步：Redis服务器进程是一个事件循环，循环中文件事件负责接收客户端的命令请求，以及向客户端发送命令回复；时间事件负责执行像serverCron这样需要定期执行的函数。服务器在结束一个事件循环之前，调用`flushAppendOnlyFile`函数考虑是否需要将aof_buf缓冲区的内容写入和保存到AOF文件中，该函数行为由服务器配置的`appendfsync`选项值决定\n\n|appendfsync选项的值|flushAppendOnlyFile函数的行为|\n|---|---|\n|always|将aof_buf缓冲区中的所有内容写入并同步到AOF文件|\n|eversync|将aof_buf缓冲区中的所有内容写入到AOF文件，若上次同步的时间超过1秒，则再次对AOF文件同步，该同步操作由一个线程专门负责执行的|\n|no|将aof_buf缓冲区的所有内容写入AOF文件，但不对文件进行同步，何时同步由操作系统决定|\n\n**AOF文件载入的过程**\n\n1) 创建一个不带网络连接的伪客户端，由于Redis命令只能在客户端中执行\n2) 从AOF文件中分析并读出一条写命令\n3) 使用伪客户端执行被读出的写命令\n4) 重复步骤2和3直到AOF文件中所有写命令被处理完毕为止\n\n###AOF重写\n随着服务器运行，AOF文件中的内容会越来越多，为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写(rewrite)功能，通过该功能，Redis服务器可以创建一个新的AOF文件来代替现有的AOF文件，新的AOF文件不会保护任何浪费空间的冗余命令。\n\n**AOF重写的实现**：通过读取服务器当前数据库的状态来实现的，而非分析现有的AOF文件\nRedis将AOF重写程序放到子进程中执行，子进程执行AOF重写期间，服务器进程可以继续处理命令请求；子进程带有服务器进程的数据副本，使用子进程而非线程，可以避免使用锁保证数据的安全性。\n\n在子进程执行AOF重写过程，服务器进程可能会执行新的修改、添加操作，这样导致数据不一致的问题，Redis设置一个AOF重写缓冲区，这个缓冲区在服务器创建子进程后开始使用，当Redis服务器执行完一个写命令之后，它会将这个写命令发送给AOF缓冲区和AOF重写缓冲区。"}