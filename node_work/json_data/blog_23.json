{"text":"###结构型模式\n结构型模式涉及到如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来\n组合接口或实现。\n结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。\n###适配器模式\n**意图**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n**动机**：有时，为复用而设计的工具箱类不能够被复用的原因仅仅是因为它的接口与专业应用领域所需要的接口不匹配。\n**适用性**\n\n- 你想使用一个已经存在的类，而它的接口不符合你的需求。\n- 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n**结构**：类适配器和对象适配器\n**类适配器**\n![Alt text](http://img.itc.cn/photo/jtLhJqQ5mFn)\n**对象适配器**\n![Alt text](http://img.itc.cn/photo/jtLdlpKiLyM)\n**参与者**\n- Target：定义Client使用的与特定领域相关的接口\n- Client：与符合Target接口的对象协同\n- Adaptee：定义一个已经存在的接口，这个接口需要适配\n- Adapter：对Adaptee的接口与Target接口进行适配\n\n**协作**：Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求\n\n###Default Adapter\nDefault Adapter：一个类需要实现一个接口，但是又不希望实现所有的方法，这个时候可以定义一个`Default Adapter`实现该接口并实现该接口所有方法，不过都是空方法或默认实现，具体在直接继承这个默认适配器即可，一般`Default Adapter`定义为抽象类。例如：`WindowAdapter`和`WindowListener`\n```\npublic abstract class WindowAdapter\n    implements WindowListener, WindowStateListener, WindowFocusListener\n{\n    public void windowOpened(WindowEvent e) {}\n    public void windowClosing(WindowEvent e) {}\n    public void windowClosed(WindowEvent e) {}\n    public void windowIconified(WindowEvent e) {}\n    public void windowDeiconified(WindowEvent e) {}\n    public void windowActivated(WindowEvent e) {}\n    public void windowDeactivated(WindowEvent e) {}\n    public void windowStateChanged(WindowEvent e) {}\n    public void windowGainedFocus(WindowEvent e) {}\n    public void windowLostFocus(WindowEvent e) {}\n}\n```\n\n###JDK中Adapter实例\n- `ByteArrayInputStream`继承`InputStream`(Target)，包含一个`byte array`(Adaptee)，将其适配为`InputStream`\n- `ByteArrayOutputStream`(Adapter)和`byte array`(Adaptee), `OutputStream`(Target)\n- `FileInputStream`(Adapter)和`FileDescriptor`(Adaptee), `InputStream`(Target)\n- `java.io.InputStreamReader(InputStream)`返回一个`Reader`(Target)，InputStreamReader将`InputStream`适配为`Reader`接口。\n![enter image description here][1]\n###相关模式\n- 模式Bridge的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而 Adapter则意味着改变一个已有对象的接口。\n- Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此Decorator对应用程序的透明性比适配器要好。结果是Decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。\n- 模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。\n\n\n  [1]: http://img.itc.cn/photo/jtKRHTUMRL8"}