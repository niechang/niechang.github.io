{"text":"###抽象工厂模式\n**意图**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。\n\n**实用性**\n\n- 一个系统要独立于它的产品的创建、组合和表示时。\n- 一个系统要由多个产品系列中的一个来配置时。\n- 当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n- 当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n**结构**\n![Alt text](http://img.itc.cn/photo/jtR3QpNXLTj)\n抽象工厂中有多个工厂方法，工厂方法数量一般对象产品种类的数目，来自同一个工厂方法返回的产品一般在一起使用。抽象工厂模式通常用工厂方法模式来实现，也可以Prototype实现。一个具体的工厂通常是Singleton。\n\n**参与者**\n\n- AbstractFactory:声明一个创建一系列产品对象的操作接口\n- ConcreteFactory:实现创建具体产品对象的操作\n- AbstractProduct:为一类产品对象声明一个接口\n- ConcreteProduct:定义一个相应具体工厂创建的产品对象\n- Client:仅使用由AbstractFactory和AbstractProduct类声明的接口\n\n**协作**\n- 通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。\n- AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。\n\n**效果**\n- 它分离了具体的类，Abstract Factory模式帮助你控制一个应用创建的对象的类\n- 它使得易于交换产品系列，一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。\n- 它有利于产品的一致性 \n- 难以支持新种类的产品，难以扩展抽象工厂以生产新种类的产品\n\n###JDK中Abstract Facotry模式\n- recognizeable by creational methods returning the factory itself which in turn can be used to create another abstract/interface type.(javadoc classes have 'Factory')\n    - javax.xml.parsers.DocumentBuilderFactory#newInstance()\n    - javax.xml.transform.TransformerFactory#newInstance()\n    - javax.xml.xpath.XPathFactory#newInstance()\n    - DatagramSocketImplFactory, PreferencesFactory\n- java.sql interfaces all get their concrete implementations from JDBC JAR when driver is registered.\n- An abstract factory has multiple factory methods, each creating a different product. The products produced by one factory are intended to be used together (your printer and cartridges better be from the same (abstract) factory). As mentioned in answers above the families of AWT GUI components, differing from platform to platform, are an example of this (although its implementation differs from the structure described in Gof).\n"}