{"text":"###享元模式\n**意图**：运用共享技术有效地支持大量细粒度的对象\n\n**动机**：有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。\n\n**内部状态**：存储于Flyweight中，它包含了独立于flyweight中场景的信息，这些信息使得flyweight中可以被共享。\n**外部状态**：取决于Flyweight场景，并根据场景而变化，因此不可共享。外部状态可以传递给flweight对象当其需要时。\n\n**适用性**：\n\n- 一个应用程序使用了大量的对象。\n- 完全由于使用大量的对象，造成很大的存储开销。\n- 对象的大多数状态都可变为外部状态。\n- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n- 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。\n\n**解构**：\n![Alt text](http://img.itc.cn/photo/jtpXliX68Dd)\n**参与者**：\n\n- Flyweight：描述一个接口，通过这个接口 Flyweight可以接受并作用于外部状态。\n- ConcreteFlyweight：实现Flyweight接口，并为内部状态(如果有的话)增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；它必须独立于ConcreteFlyweight对象的场景\n- UnsharedConcreteFlyweight：并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次， UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点\n- FlyweightFactory：创建并管理flyweight对象，确保合理地共享flyweight。当用户请求一个flyweight时， FlyweightFactory对象提供一个已创建的实例或者创建一个\n- Client：维持一个对flyweight的引用;计算或存储一个（多个）flyweight的外部状态\n\n**协作**：\n\n- flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。\n- 用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。\n\n**效果**：使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的Flyweight越多，存储节约也就越多\n\n**实现**：\n\n- **删除外部状态**。该模式的可用性在很大程度上取决于是否容易识别外部状态并将它从共享对象中删除。外部状态可以由client通过参数传递给flyweight；封装外部状态和相应的行为到一个独立的解构\n- **管理共享对象**。因为对象是共享的，用户不能直接对它进行实例化，因此FlyweightFactory可以帮助用户查找某个特定的Flyweight对象。FlyweightFactory对象经常使用关联存储帮助用户查找感兴趣的Flyweight对象。共享还意味着某种形式的引用计数和垃圾回收，这样当一个Flyweight不再使用时，可以回收它的存储空间。\n\n###JDK中实例\n- `java.lang.Integer#valueOf(int)` (also on Boolean, Byte, Character, Short and Long)\n- 各种pool如：Thread pools, connection pools, EJB object pools(享元模式用于管理共享的资源)"}