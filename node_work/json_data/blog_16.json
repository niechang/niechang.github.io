{"text":"###原型模式\n**意图**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\nPrototype以下场景非常适用：\n\n- 复杂的内部结构\n- 对象很难创建或者不能创建\n- 初始状态很复杂\n\n**适用性**  \n当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式；以及   \n\n- 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者\n- 为了避免创建一个与产品类层次平行的工厂类层次时；或者\n- 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些\n\n**结构**  \n![Prototype structure](http://img.itc.cn/photo/jtUUFLYnZ91)\n\n**参与者**\n\n- Prototype:声明一个克隆自身的接口\n- ConcretePrototype:实现一个克隆自身的操作\n- Client:让一个原型克隆自身从而创建一个新的对象\n\n**效果**\n\nPrototype有许多和Abstract Factory和Builder一样的效果：它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。此外，这些模式使客户无需改变即可使用与特定应用相关的类。\n\n- 运行时刻增加和删除产品\n- 改变值以指定新对象\n- 改变结构以指定新对象\n- 减少子类的构造\n- 用类动态配置应用\n- 每个Prototype的子类都必须实现clone方法\n\n###扩展\n\n类中包含一个`clone()`方法用于复制自己本身，对象是否允许完整的拷贝自身完全有该对象本身决定。  \n`java.lang.Object`中定义了`clone()`方法，默认方法是没有实现的，用户可以实现`java.lang.Cloneable`接口来实现原型。\n```\nprotected native Object clone() throws CloneNotSupportedException;\n```\n每个对象x，clone方法满足:   \nx.clone().getClass() == x.getClass()  \nx.clone() != x  \nx.clone().equals(x) (若对象equals方法根据value进行比较)\n单例类中clone方法应该是不支持的  \n一个类需要支持clone，应该重写clone方法并设置为public  \n\n**Shallow copy和Deep copy**  \nShallow copy：只拷贝原始对象本身的值，对于引用成员只拷贝引用;  \nDeep Copy：对象完整的拷贝，包括引用的对象  \n\nclone()方法中不能修改final域的值，因此不能拷贝final域的成员，必须修改final修饰符。可以通过序列化的方式进行拷贝，但是序列化代价往往比直接clone高很多  \nSerialization:将对象当前状态存储为一个流对象  \nDeserialization：将一个流对象恢复为等价的对象\n\n**JDK中原型模式实例**  \n`java.lang.Object#clone()` (the class has to implement `java.lang.Cloneable`)\n\n"}