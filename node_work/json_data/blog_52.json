{"text":"###30. 使用enum代替int常量\nJava枚举类型本质是一个int值，其通过公有的静态final域为每个枚举常量导出实例的类。 枚举相比int常量要易读，也更安全，功能更强大。如果多个枚举类型常量同时共享相同的行为，考虑策略枚举。\n```Java\npublic enum Operation{\n    PLUS {double apply(double x, double y) {return x + y;}},\n    MINUS {double apply(double x, double y) {return x - y;}};\n    abstract double apply(double x, double y);\n}\n```\n\n###31. 用实例域代替序数\n所有枚举都有一个`ordinal`方法，返回每个枚举值在常量类型中的位置。 永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。 Enum规范中关于ordinal描述：大多数程序员都不需要这个方法，它是设计成用于像EnumSet和EnumMap这样基于枚举的通用数据结构的。\n\n###32. 用EnumSet代替位域\n某些情况下用int常量作为枚举可以方便进行位运算，用OR运算将几个常量合并到一个集合中称为位域。位域存在int枚举常量的所有缺点，考虑使用`EnumSet`代替，由于`EnumSet`底层是采用long或long数组实现因此很高效。\n\n###33. 用EnumMap代替序数索引\n最好不要用序数来索引数组，而要使用EnumMap。如果是处理多维关系，就使用`EnumMap<.., EnumMap<..>>`。由于数组不能与泛型兼容，使用数组表示枚举之间关系存在未受检的警告，因为数组不知道其索引代表着什么。`EnumMap`内部才用数组方式实现保持高效。\n```JAVA\npublic class Herb{\n    public enum Type { ANNUAL, PERNNIAL, BIENNIAL}\n    private final Type type;\n    //...\n}\nSet<Herb> herbByType = new Set<Herb>[Herb.Type.values.length()];\nMap<Herb.Type, Set<Herb>> herbByType = new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);\n```\n\n###34. 用接口模拟可伸缩的枚举\n虽然无法编写可扩展的枚举类型，但可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。 有一个缺陷无法将实现一个枚举类型继承到另一个枚举类型。\n\n###35. 注解优先于命名模式\n命名模式用于表面有些程序元素需要通过某种工具或框架执行特殊处理，如Junit早期版本测试方法必须testXxx，后来用注解`@Test`代替。命名模式存在以下缺陷\n\n- 文字拼写错误会导致失败，且没有任何提示\n- 无法确保它们只用于相应的程序元素上\n- 没有提供将参数值与程序元素关联起来的好方法\n\n###36. 坚持使用Override注解\n想要覆盖超类声明的每个方法声明中使用Override注解，这样编译器就可以替你防止大量的错误，有个例外在具体类中，不必标注覆盖了抽象方法。\n\n###37. 用标记接口定义类型\n标记接口(marker interface)：是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。\n若标记是应用到任何程序元素而不是类或接口，就必须使用注解。只有类和接口可以用来实现或者扩展接口。\n"}