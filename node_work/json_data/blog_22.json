{"text":"###泛型\nJava泛型是从1.5开始引入，编译器帮助跟踪参数类型，检查类型是否匹配并进行转换，编译器能保证类型转换不会失败。\n\n- 泛型类\n- 泛型接口\n- 泛型方法\n- 泛型构造器\n\n###泛型中通配符\njava中子类的实例可以赋值给父类，但是相应的泛型类型不行。但是可以用通配符来进行类似操作。\n\n- 协变(Narrowing a reference, Upper Bounded Wildcard)：`? extends T`类型不能加入任何实际对象，虽然通配符表示任何T及其子类型但是不清楚具体哪一个类型，为了保证类型安全，不允许加入任何实例。但是从该类型中取元素可以直接赋值给`T`。 \n- 逆变(Widening a reference, Lower bounded Wildcard)： `? super T`可以用于put对象实例到相应数据结构中\n- 无边界泛型(Unbounded Wildcard)：`List<?>`\n\n```\nList<Number> numLists = null;\nList<Integer> intLists = null;\nintLists = numLists; // invalid, comiple error\n\n//OK, Covariance 协变性, Number或Number的子类型\nList<? extends Number> list1 = intLists; \n//OK, Contravariance 逆变性, Number或Number父类型\nList<? super Number>  list2 = numLists;\nList<? super Integer> list3 = numLists;\n\nlist1.add(new Integer(1)); //编译错误，虽然Integer是Number的子类型\nlist3.add(new Integer(1)); //OK\nlist3.add(new Object()); //编译错误\n```\n\n**PECS规则**\n\n- `? extends T`用于从数据结构中取出元素(get操作)\n- `? super T`用于往数据结构中存放元素(put操作)\n- 若两者都需要，不要使用任何通配符\n\n通配符用于方法签名，可以参考上述规则，若需要接收某个子类型参数读操作可以用`? extends T`，若需要放入对象实例(写操作)可以用`? super T`。\n```\nvoid eat(List<? extends Fruit> fruits);\nvoid store(List<? super Fruit> container);\n```\n\n###泛型变量的边界\n泛型不能用`super`来划定边界，只能用`extends`。\n例如`public static <T extends I<T>> void name(Collection<T> t);`，参数t为Collection类型，其内部元素设定了边界，类型必须满足`T extends I<T>`。\n\n```\npublic interface Juicy<T> {\n    Juice<T> squeeze();\n}\n//takes a bunch of fruits and squeezes them all\n<T> List<Juice<T>> squeeze(List<Juicy<T>> fruits);\n//bounded type variables\n<T extends Juicy<T>> List<Juice<T>> squeeze(List<T> fruits);\n\n//squeeze(new ArrayList<RedOrange>()); compile error\nclass Orange extends Fruit implements Juicy<Orange>;\nclass RedOrange extends Orange;\n\n<T extends Juicy<? super T>> List<Juice<? super T>> squeezeSuperExtends(List<? extends T> fruits);\n//多个泛型参数\n<T extends Juicy<S>, S extends Fruit> List<Juice<S>> squeezeSuperExtendsWithFruit(List<? extends T> fruits);\n```\n递归边界：`<T extends Juicy<? super T>>`  \n多重边界：`<T extends A & B>`，其中A,B为类或接口，但不能同时都为类\n\n泛型命名规范\n\n- E – Element (used extensively by the Java Collections Framework, for example ArrayList, Set etc.)\n- K – Key (Used in Map)\n- N – Number\n- T – Type\n- V – Value (Used in Map)\n- S,U,V etc. – 2nd, 3rd, 4th types\n\n###类型擦除\njava中泛型采用类型擦除方式实现，只在编译期间有效，不保存到运行期间，生成代码用Object或者指定的下边界类型进行替换。\n```\nclass Test<T extends Comparable<T>> {\n    private T data;\n    private Test<T> next;\n}\n//编译以后实际变为\npublic class Test {\n    private Comparable data;\n    private Test next;\n}\n```\n\n###参考资料\n- [Core Java Tutorials](http://www.javacodegeeks.com/tutorials/java-tutorials/core-java-tutorials/#Functional%20programming)\n- [Java泛型笔记](http://www.itzhai.com/java-bi-ji-fan-xing-fan-xing-fang-fa-fan-xing-jie-kou-ca-chu-bian-jie-tong-pei-fu.html)\n"}