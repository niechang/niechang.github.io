{"text":"###EnumSet\n1. EnumSet中所有值都必须是指定枚举类型的值，它的元素也是有序的，以枚举值在枚举类的定义顺序来决定集合元素的顺序。\n2. EnumSet集合不允许加入null元素，否则会抛出NullPointerException异常。\n3. EnumSet内部用bit向量表示，时间和空间性能都非常高效。\n4. EnumSet返回的迭代器是弱一致的，不会抛出`ConcurrentModificationException`。\n5. EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的static方法来创建EnumSet对象，常用的static方法如下：\n\n| 方法      |    说明 |\n| :---------| :--------| \n| allOf(Class type)  | 创建一个包含指定枚举类里所有枚举值的EnumSet集合 | \n| complementOf(EnumSet s)  | 创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet，新的EnumSet集合包含原EnumSet集合所不包含的、此枚举类剩下的枚举值 |  \n| copyOf(Collection c)      | 创建一个与指定EnumSet具有相同元素类型、相同集合元素的EnumSet | \n| copyOf(EnumSet e)      | 创建一个元素类型为指定枚举类型的空EnumSet | \n| copyOf(EnumSet e)      | 创建一个元素类型为指定枚举类型的空EnumSet | \n| of(E first,E...rest)      | 创建一个包含一个或多个枚举值的EnumSet，传入的多个枚举值必须属于同一个枚举类 | \n| of(E from,E to)      | 创建包含从from枚举值，到to枚举值范围内所有枚举值的EnumSet集合 | \n\n###EnumSet实现之RegularEnumSet\n类的定义和成员，注意一点EnumSet是抽象类，因此不能够直接初始化，EnumSet有两种实现，`RegularEnumSet`由一个单独的long存储（能够存储64个枚举值），`JumboEnumSet`由long[]存储。\n```\npublic abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E>\n    implements Cloneable, java.io.Serializable{\n    \n    final Class<E> elementType;\n    \n    final Enum[] universe; //All of the values comprising T\n    \n     EnumSet(Class<E>elementType, Enum[] universe) {\n        this.elementType = elementType;\n        this.universe    = universe;\n    }\n    \n    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {\n        Enum[] universe = getUniverse(elementType);\n        if (universe == null)\n            throw new ClassCastException(elementType + \" not an enum\");\n        if (universe.length <= 64)\n            return new RegularEnumSet<E>(elementType, universe);\n        else\n            return new JumboEnumSet<E>(elementType, universe);\n    }\n    \n    public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType) {\n        EnumSet<E> result = noneOf(elementType);\n        result.addAll();\n        return result;\n    }\n    \n    public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s) {\n        EnumSet<E> result = copyOf(s);\n        result.complement();\n        return result;\n    }\n    \n    public static <E extends Enum<E>> EnumSet<E> range(E from, E to) {\n        if (from.compareTo(to) > 0) //from > to\n            throw new IllegalArgumentException(from + \" > \" + to);\n        EnumSet<E> result = noneOf(from.getDeclaringClass());\n        result.addRange(from, to);\n        return result;\n    }\n    \n    abstract void addAll();\n}\n```\n`RegularEnumSet`的实现，可以看到这个class没有声明为public，只能包内其他类引用，因此对于应用程序来说其实是不可见的。\n内部用一个64bit的long类型表示枚举元素是否在集合中，第k个bit是否为1，表示是否包含enum中第k(ordinal属性)个元素是否存在。\n\n可以看到add、remove和contains这类操作都是通过位操作实现的，首先将1左移相应位数(enum实例对应ordinal值)，然后和原来bit vector或操作可以实现添加，取反后与操作实现删除，直接与判断结果是否为0实现查询。\n```\nclass RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {\n   //表示EnumSet的bit vector，2^k bit 表示universe[k]在set中\n    private long elements = 0L; \n    \n    RegularEnumSet(Class<E>elementType, Enum[] universe) {\n        super(elementType, universe);\n    }\n    \n    void addAll() {\n        if (universe.length != 0)\n            elements = -1L >>> -universe.length;\n    }\n    //enum中第0个元素 1 << 0 = 1, 第1个元素 1 << 1 = 10(二进制表示)\n    public boolean add(E e) {\n        typeCheck(e);\n        long oldElements = elements;\n         //左移ordinal个位置，和原来bit vector或操作实现添加\n        elements |= (1L << ((Enum)e).ordinal());\n        return elements != oldElements;\n    }\n    \n    /*\n     * 将[form,to]之间的bit设置为1, eg: [1,5]  0011 1110\n     * (-1L >>> (1 - 5 - 1)) << 1 = 0001 1111 << 1 = 0011 1110\n     * 先构造出(to-from+1)个1构成的bit，然后左移from\n     */\n    void addRange(E from, E to) {\n        elements = (-1L >>>  (from.ordinal() - to.ordinal() - 1)) << from.ordinal();\n    }\n    \n    public boolean remove(Object e) {\n        if (e == null)\n            return false;\n        Class eClass = e.getClass();\n        if (eClass != elementType && eClass.getSuperclass() != elementType)\n            return false;\n        long oldElements = elements;\n        //e对应的bit取反，然后和原来bit vector与操作来实现删除\n        elements &= ~(1L << ((Enum)e).ordinal());\n        return elements != oldElements;\n    }\n    \n    public boolean contains(Object e) {\n        if (e == null)\n            return false;\n        Class eClass = e.getClass();\n        if (eClass != elementType && eClass.getSuperclass() != elementType)\n            return false;\n        return (elements & (1L << ((Enum)e).ordinal())) != 0;\n    }\n    \n    void complement() { //取补集, EnumSet.complementOf调用\n        if (universe.length != 0) {\n            elements = ~elements;\n            elements &= -1L >>> -universe.length;  // Mask unused bits,没用到的bits置0\n        }\n    }\n    \n    public int size() {\n        return Long.bitCount(elements);\n    }\n    \n    public boolean isEmpty() {\n        return elements == 0;\n    }\n}\n```\n###迭代器的实现\nEnumSet具体的实现在子类`RegularEnumSet`和`JumboEnumSet`中，迭代器也是相应子类的内部类。迭代过程也是利用位运算来完成，利用`x & -x`当x为偶数时返回x中2的最大次方的因子，bit vector减去这个因子就可以删除当前位置的bit，可以看注释说明。\n```\npublic Iterator<E> iterator() {\n    return new EnumSetIterator<E>();\n}\nprivate class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {\n     long unseen; //bit vector代表还未被迭代器返回的元素\n     long lastReturned = 0;\n     EnumSetIterator() {\n        unseen = elements;\n     }\n\n     public boolean hasNext() {\n        return unseen != 0;\n     }\n     \n     public E next() {\n        if (unseen == 0)\n            throw new NoSuchElementException();\n        /*\n         * x&-x含义：当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子\n         * unseen = 11 1111 (初始化有6个enum元素)\n         * 1) lastReturned = 1, unseen = 11 1110 (62)\n         * 2) lastReturned = 2, unseen = 11 1100 (60)\n         * 3) lastReturned = 4, unseen = 11 1000 (56)\n         *  ...\n        */\n        lastReturned = unseen & -unseen;\n        unseen -= lastReturned;\n        return (E) universe[Long.numberOfTrailingZeros(lastReturned)];\n    }\n    \n     public void remove() {\n        if (lastReturned == 0)\n            throw new IllegalStateException();\n        elements -= lastReturned;\n        lastReturned = 0;\n    }\n }\n```\n###EnumSet实现之JumboEnumSet\n`JumboEnumSet`用于当enum类型中元素超过64的时候，一个long类型的bit位表示不下，改用long[]数组类型来支持。其实和`RegularEnumSet`类似也是利用位操作来完成，不过是每个long数组中元素分别表示64个enum元素是否存在集合中，因此添加删除元素之前需要找到数组中对应的位置，然后再进行相应的位操作。\n```\nclass JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {\n    /**\n     * Bit vector representation of this set.  The ith bit of the jth\n     * element of this array represents the  presence of universe[64*j +i]\n     * in this set.\n     */\n    private long elements[];\n\n    // Redundant - maintained for performance\n    private int size = 0;\n    \n    JumboEnumSet(Class<E>elementType, Enum[] universe) {\n        super(elementType, universe);\n        //无符号右移6位(除以64),计算数组大小 == (universe.length + 64 - 1)/64 \n        elements = new long[(universe.length + 63) >>> 6];\n    }\n    \n    public boolean add(E e) {\n        typeCheck(e);\n        int eOrdinal = e.ordinal();\n        int eWordNum = eOrdinal >>> 6; // eOrdinal/64\n    \n        long oldElements = elements[eWordNum];\n        elements[eWordNum] |= (1L << eOrdinal);\n        boolean result = (elements[eWordNum] != oldElements);\n        if (result)\n            size++;\n        return result;\n    }\n    \n    public boolean remove(Object e) {\n        if (e == null)\n            return false;\n        Class eClass = e.getClass();\n        if (eClass != elementType && eClass.getSuperclass() != elementType)\n            return false;\n        int eOrdinal = ((Enum)e).ordinal();\n        int eWordNum = eOrdinal >>> 6;\n        long oldElements = elements[eWordNum];\n        elements[eWordNum] &= ~(1L << eOrdinal);\n        boolean result = (elements[eWordNum] != oldElements);\n        if (result)\n            size--;\n        return result;\n    }\n    \n    public boolean contains(Object e) {\n        if (e == null)\n            return false;\n        Class eClass = e.getClass();\n        if (eClass != elementType && eClass.getSuperclass() != elementType)\n            return false;\n        int eOrdinal = ((Enum)e).ordinal();\n        return (elements[eOrdinal >>> 6] & (1L << eOrdinal)) != 0;\n    }\n}\n```\n###总结\n1. EnumSet用于存放Enum类型的不重复元素集合，并且遍历时候保证元素的顺序，即enum成员ordinal的顺序。同样是非线性安全的容器，迭代器是弱一致的，不支持`fail-fast`。\n2. EnumSet本身是一个抽象类，提供一系列工厂方法返回EnumSet实例，内部实现两种类型集合：`RegularEnumSet`和`JumboEnumSet`。当enum类中成员不超过64个时，用`RegularEnumSet`，其内部利用一个long类型表示bit vector，代表枚举成员e是否在集合中，通过bit vector第i个bit表示e.ordinal()对应的枚举e。内部添加、删除、检查都是通过位操作完成性能很高。\n3. `JumboEnumSet`用于当枚举元素超过64个时，内部用一个long[]数组表示，操作和`JumboEnumSet`类似，不过需要先定位到数组中下标，然后再对该位置的bit vector进行位操作。\n4. 迭代器在`RegularEnumSet`和`JumboEnumSet`内部类中实现，也是通过位操作实现，这两个类对于学习位操作很有帮助，活生生的例子。\n"}