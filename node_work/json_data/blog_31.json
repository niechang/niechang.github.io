{"text":"###Java NIO\n标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n\nJava NIO由以下几个核心部分组成：  \n\n- Channel：Channel有点象流，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。\n    - FileChannel：从文件中读写数据\n    - DatagramChannel：能通过UDP读写网络中的数据\n    - SocketChannel：能通过TCP读写网络中的数据\n    - ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel\n- Buffer\n    - ByteBuffer\n    - CharBuffer\n    - DoubleBuffer\n    - FloatBuffer\n    - IntBuffer\n    - LongBuffer\n    - ShortBuffer\n    - MappedByteBuffer：用于表示内存映射文件\n- Selector：择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。\n\n###Buffer\nBuffer用于和NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。\n\n**Buffer的基本用法**\n使用Buffer读写数据一般遵循的4个步骤：\n\n1. 写入数据到Buffer\n2. 调用flip()方法\n3. 从Buffer中读取数据\n4. 调用clear()或compact()方法\n\n当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。\n一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。`clear()`方法会清空整个缓冲区。`compact()`方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。\n\n**Buffer三个关键属性**\n\n- capacity：作为一个内存块，Buffer有一个固定的大小值，你只能往里写capacity个byte、long，char等类型。\n- position：\n    - 当你写数据到Buffer中时，position表示当前的位置。初始的position值为0，当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元，position最大可为capacity–1。\n    - 当读取数据时，也是从某个特定位置读，当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置\n- limit：\n    - 在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据， 写模式下limit等于Buffer的capacity。\n    - 当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）\n\n**Buffer相关方法**\n\n- allocate静态方法，要想获得一个Buffer对象首先要进行分配。`ByteBuffer buf = ByteBuffer.allocate(48)`\n- 向Buffer中写数据\n    - 从Chanel写到Buffer `int bytes = inChanel.read(buf);`\n    - 通过put方法 `buf.put(127);`\n- 从Buffer中读数据\n    - 从Buffer读取数据到Channel `int bytesWritten = inChannel.write(buf);`\n    - 使用get方法 `byte aByte = buf.get();`\n- flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。\n- rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。\n- clear()方法，position将被设回0，limit被设置成capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。\n- compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。\n- mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position\n\n**Scatter/Gather**\n\n- 分散scatter从Channel中读取是指在读操作时将读取的数据写入多个buffer中。`channel.read(Buffer[])`，Scattering Reads在移动下一个buffer前，必须填满当前的buffer。\n- 聚集Gathering Writes是指数据从多个buffer写入到同一个channel。`chanel.put(Buffer[])`，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。\n\n###Chanel\nJava NIO的通道类似流，但又有些不同：\n\n- 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。\n- 通道可以异步地读写。\n- 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。\n\n###FileChannel\nJava NIO中的FileChannel是一个连接到文件的通道，可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\n通过使用一个`FileInputStream`、`FileOutputStream`或`RandomAccessFile`的`getChannel()`方法来获取一个FileChannel实例。返回的FileChanel实例连接到相同的底层文件，channel的position改变会映射到同样文件源的poistion，同样源文件position改变也会反映到channel实例上。文件的大小和内容都有同样的映射关系。\nFileChannel除了通用的read、write、close等操作，还有一些和文件相关的特定操作：\n\n- 可以read和write特定位置的bytes，且不会影响通道的当前position\n- 文件的一个区域可以直接映射到内存，对于大文件这种方式比通常read和write效率更高\n- 文件更新操作可能需要调用force方法强制写入存储设备\n- Bytes可以传送到其他通道，反过来其他通道也可以传送到文件通道\n- 文件的区域可以被其他程序锁定\n\n**使用方法**\n可以向FileChannel中读取数据read(ByteBuffer)、写数据put(ByteBuffer)、传输数据transferTo(long start, long count, Channel dest)\n```\npublic static void readData(String path) throws IOException {\n\tRandomAccessFile aFile = new RandomAccessFile(path, \"r\");\n\tFileChannel channel = aFile.getChannel();\n\tByteBuffer buf = ByteBuffer.allocate(48);\n\tint bytesRead = channel.read(buf);//从FileChannel读取数据 \n\twhile(bytesRead!=-1) {\n\t\tbuf.flip(); // make buffer ready for read\n\t\twhile(buf.hasRemaining()){\n\t\t\tSystem.out.print((char) buf.get()); //read 1 byte at a time\n\t\t}\n\t\tbuf.clear();\n\t\tbytesRead = channel.read(buf);\n\t}\n\tchannel.close();\n\taFile.close();\n}\n\t\npublic static void writeData(String data, String path)throws IOException{\n\tRandomAccessFile aFile = new RandomAccessFile(path, \"rw\");\n\tFileChannel channel = aFile.getChannel();\n\tByteBuffer buf = ByteBuffer.allocate(48);\n\tbuf.clear();\n\tbuf.put(data.getBytes());\n\tbuf.flip();\n\twhile(buf.hasRemaining()) {\n        //无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法\n\t\tchannel.write(buf);\n\t}\n\tchannel.close();\n\taFile.close();\n}\n\npublic static void copyFile(String src,String dest) throws IOException {\n\tFileInputStream  inStream = new FileInputStream(src);\n\tFileChannel\t\t fromChannel = inStream.getChannel();\n\tFileOutputStream outStream = new FileOutputStream(dest);\n\tFileChannel\t\t toChannel = outStream.getChannel();\n\tlong\t\t\t count = fromChannel.size();\n\tfromChannel.transferTo(0, count, toChannel);\n\ttoChannel.close();\n\tfromChannel.close();\n\toutStream.close();\n\tinStream.close();\n}\n```\n###SocketChannel\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道，可以通过下面方式创建该通道实例：\n\n1. 打开一个SocketChannel并连接到互联网上的某台服务器。\n2. 一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。\n\n```\nSocketChannel socketChannel = SocketChannel.open();\nsocketChannel.connect(new InetSocketAddress(\"localhost\", 80));\n```\n\n**非阻塞模式**\n可以设置 SocketChannel 为非阻塞模式(non-blocking mode)设置之后，就可以在异步模式下调用connect(), read() 和write()了。\n- 如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。\n\n- 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。\n- 非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。\n- 非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。\n\n```\nsocketChannel.configureBlocking(false);\nsocketChannel.connect(new InetSocketAddress(\"localhost\", 80));\nwhile(! socketChannel.finishConnect() ){\n    //wait, or do something else...\n}\n```\n###ServerSocketChannel\n ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。\n```\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\nserverSocketChannel.socket().bind(new InetSocketAddress(9999));\nwhile(true){\n    SocketChannel socketChannel = serverSocketChannel.accept();\n    //do something with socketChannel...\n}\n```\nServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null。\n\n###DatagramChannel\nDatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。\n```\nDatagramChannel channel = DatagramChannel.open();\nchannel.socket().bind(new InetSocketAddress(9999));\nByteBuffer buf = ByteBuffer.allocate(48);\nbuf.clear();\n//receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。\nchannel.receive(buf);\n\nint bytesSent = channel.send(buf, new InetSocketAddress(\"jenkov.com\", 80));\n\nchannel.connect(new InetSocketAddress(\"jenkov.com\", 80));\n//当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。\n```\n###Pipe管道\nJava NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。\n![Alt text](http://ifeve.com/wp-content/uploads/2013/06/pipe.bmp)\n要向管道写数据，需要访问sink通道;从读取管道的数据，需要访问source通道。\n```\nPipe pipe = Pipe.open(); //通过Pipe.open()方法打开管道\n\nPipe.SinkChannel sinkChannel = pipe.sink();\nByteBuffer buf = ...;\nwhile(buf.hasRemaining()) {\n    sinkChannel.write(buf);\n}\n\nPipe.SourceChannel sourceChannel = pipe.source();\nint bytesRead = sourceChannel.read(buf);\n```\n###Selector\nSelector(选择器)是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。\n```\nSelector selector = Selector.open(); //创建一个Selector\nchannel.configureBlocking(false); //channel必须处于非阻塞模式下\n//为了将Channel和Selector配合使用，必须将channel注册到selector上\nSelectionKey key = channel.register(selector,Selectionkey.OP_READ);\n\n```\nregister()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来。\n\n- Connect：客户端连接服务端事件 SelectionKey.OP_CONNECT\n- Accept：服务端接收客户端连接事件 SelectionKey.OP_ACCEPT\n- Read：读事件 SelectionKey.OP_READ\n- Write：写事件 SelectionKey.OP_WRITE\n\n**SelectionKey**\n当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：\ninterest集合：interest集合是你所选择的感兴趣的事件集合，可以通过SelectionKey读写interest集合`int interestSet = selectionKey.interestOps();`\nready集合：是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。\n```\nint readySet = selectionKey.readyOps();\nselectionKey.isAcceptable();//来检测channel中什么事件或操作已经就绪\nselectionKey.isConnectable();\nselectionKey.isReadable();\nselectionKey.isWritable();\n```\nChannel和Selector\n```\nChannel  channel  = selectionKey.channel();\nSelector selector = selectionKey.selector();\n```\n附加对象：可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。\n```\nselectionKey.attach(theObject);\nObject attachedObj = selectionKey.attachment();\n//还可以在用register()方法向Selector注册Channel的时候附加对象\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);\n```\n\n**通过Selector选择通道**\n一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。\nselect()阻塞到至少有一个通道在你注册的事件上就绪了。\nselect(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。\nselectNow()不会阻塞，不管什么通道就绪都立刻返回(此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零)。\nselectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。可以遍历这个已选择的键集合来访问就绪的通道。\n```\nSet selectedKeys = selector.selectedKeys();\nIterator keyIterator = selectedKeys.iterator();\nwhile(keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if(key.isAcceptable()) {\n        // a connection was accepted by a ServerSocketChannel.\n    } else if (key.isConnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isReadable()) {\n        // a channel is ready for reading\n    } else if (key.isWritable()) {\n        // a channel is ready for writing\n    }\n    keyIterator.remove();\n}\n```\nwakeUp()某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。\n###参考\n[Java NIO系列教程](http://ifeve.com/java-nio-all/)\n"}