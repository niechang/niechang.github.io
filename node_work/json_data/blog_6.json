{"text":"###注解\n注解是从JDK5中引入的新特性，注解是插入代码中的一种注释或者说是元数据。这些信息可以在编译期使用预编译工具进行处理，也可以在运行时使用反射机制进行处理。\n**元注解**：元注解用于对注解本身进行描述，JDK中提供4种元注解\n\n- @Target：注解应用的目标元素，取值为`ElementType`枚举类型包括如下\n - TYPE(类、接口、枚举声明)\n - FIELD(变量)\n - METHOD(方法)\n - PARAMETER(参数)\n - CONSTRUCTOR(构造函数)\n - LOCAL_VARIABLE(局部变量)\n - PACKAGE(包)\n- @Retention：注解的保留期限\n  - RetentionPolicy.SOURCE：只在源码中有用，就像注释一样不会编译进字节码\n  - RetentionPolicy.CLASS：保存到字节码中，但虚拟机运行时不保留，默认值\n  - RetentionPolicy.RUNTIME：保存到字节码中并加载到虚拟机中，可以通过反射取出来\n- @Documented：在默认的情况下在使用javadoc自动生成文档时，注解将被忽略掉。如果想在文档中也包含注解，必须使用Documented为文档注解。\n- @ Inherited：在默认的情况下，父类的注解并不会被子类继承。如果要继承，就必须加上Inherited注解。只适用于类的继承，接口之间继承和类实现接口无效。\n\n**Java 8 与注解**\n\n- @Repeatable：说明该注解标识的注解可以多次使用到同一个元素的声明上\n- 自Java8开始，我们可以在类型上使用注解。由于我们在任何地方都可以使用类型，包括 new操作符，casting，implements，throw等\n- @FunctionalInterface：这个注解表示一个函数式接口元素。函数式接口是一种只有一个抽象方法。\n\n###JDK中注解和注解的使用\nJDK中默认注解包括：@Override、@Deprecated\n\n- @Override：作用在方法上，保留期为SOURCE，表示某个方法必须为覆盖父类的方法\n- @Deprecated：保留期为RUNTIME，标记注解，就是在源程序中加入这个标记后，并不影响程序的编译，但有时编译器会显示一些警告信息。表示属性或方法过期。\n- @SuppressWarnings：抑制编译器产生警告信息的\n- @SafeVarargs：断言方法或者构造器的代码不会对参数进行不安全的操作\n\n**注解的使用**\nAnnotation声明通过关键字@interface，其属性必须带有小括号(定义更像方法)。当注解中只有一个value属性时，可以省略属性名对其进行直接赋值。\n```\n@Retention(RetentionPolicy.RUNTIME)\n@interface MyAnnotation {\n    String   value() default \"\"; //默认值\n    String   name();\n    int      age();\n}\n@MyAnnotation(\n    name=\"Jakob\",\n    age=37)\npublic class MyClass {\n   public static void main(String[] args) {\n\t\tClass clazz = MyClass .class;\n\t\tMyAnnotation annotation = (MyAnnotation) clazz.getAnnotation(MyAnnotation.class);\n\t\tSystem.out.println(annotation.name() + \" \" + annotation.age());\n\t}\n}\n```\n###枚举enum\n- java中枚举通过enum关键字声明，本质是一个继承`java.lang.Enum`的类，而且不能被继承的final类，其枚举值都是`Color`类型的静态常量(public static final)，因此一般都大写。\n- 枚举类中可以有构造器，但只能是private，这样外部代码无法构造枚举实例，构造器只是在构造枚举值时调用。\n- 所有枚举类都继承了Enum类中的方法\n  - ordinal()：返回枚举值得顺序，根据声明顺序决定\n  - values()：返回包含所有枚举值的数组\n - toString()：枚举常量的名字\n  - valueOf(String)：返回带指定名称的枚举类型\n```\npublic enum Color {\n   RED, BLUE, YELLOW, GREEN\n}\n\npublic abstract class Enum<E extends Enum<E>>\n        implements Comparable<E>, Serializable {\n        \n    //enum常量的名字，通过toString()方法获取\n    private final String name;\n\n    public final String name() {\n        return name;\n    }\n\n    //枚举常量声明的顺序，用于EnumSet和EnumMap中\n    private final int ordinal;\n\n    //返回枚举常量的顺序\n    public final int ordinal() {\n        return ordinal;\n    }\n\n    //程序员不能调用，由编译器调用生成具体的枚举类\n    protected Enum(String name, int ordinal) {\n        this.name = name;\n\t    this.ordinal = ordinal;\n    }\n\n    //这个方法可以被子类具体enum覆盖\n    public String toString() {\n\t    return name;\n    }\n}\n```\n用户通过关键字声明enum类以后，对应会生成相应的字节码文件，编译器会默认生成继承`java.lang.Enum`的final类，所有定义的枚举实例会根据变量名字和声明顺序设置name和ordinal值，其中`value()`和`values()`方法由编译生成(Enum类中也没有定义)。单例模式可以通过枚举来实现。"}