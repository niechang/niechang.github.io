{"text":"Redis中主要数据结构包括：简单字符串、双端队列、跳跃表、字典、压缩列表、整数集合等。\nRedis基于这些数据结构创建一个对象系统，包括：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。\nRedis对象系统还实现了基于引用计数的内存回收机制。\nRedis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，服务器启用maxmomery情况下，空转时间长的那些键可能会优先删除。\nRedis中的每个对象都由一个redisObject结构表示，该结构中保存数据相关的三个属性：type、encoding、ptr。\n\nRedis中的每个对象都由一个redisObject结构表示，该结构中保存数据相关的三个属性：type、encoding、ptr。\n```\ntypedef struct redisObject {\n    unsigned type: 4; //类型\n    unsigned encoding: 4; //编码\n    void *ptr; //指向底层实现数据结构的指针\n    int refcount;//引用计数\n    unsigned lru:22; //最近使用的时间\n} robj;\n```\ntype属性记录了对象的类型，Redis中键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或有序集合对象的其中一种。\n\n| 对象的名称 | type属性的值 | type命令返回值 |\n|---|---|---|\n|字符串对象|REDIS_STRING|\"string\"|\n|列表对象|REDIS_LIST| \"list\" |\n|哈希对象|REDIS_HASH| “hash\" |\n|集合对象|REDIS_SET| ”set\" |\n|有序集合对象|REDIS_ZSET| \"zset\"|\n\nencoding属性记录对象使用的编码，即对象使用什么数据结构作为对象的底层实现。\n\n|对象所使用底层数据结构|编码常量|OBJECT ENCODING命令输出|\n|---|---|---|\n|整数|REDIS_ENCODING_INT|\"int“|\n|embstr编码的简单动态字符串|REDIS_ENCODING_EMBSTR|\"embstr\"|\n|简单动态字符串|REDIS_ENCODING_RAW|”raw\"|\n|字典|REDIS_ENCODING_HT|\"hashtable\"|\n|双端链表|REDIS_ENCODING_LINKEDLIST|“linkedlist”|\n|压缩列表|REDIS_ENCODING_ZIPLIST|“ziplist\"|\n|整数集合|REDIS_ENCODING_INTSET|”intset\"|\n|跳跃表和字典|REDIS_ENCODING_SKIPLIST|“skiplist\"|\n\n###字符串对象\n字符串对象的编码可以是int、raw或embstr\n\n- 如果字符串对象保存的是整数值且可以用long类型来表示，那么整数值保存在对象的ptr属性中，且encoding属性设置为int。可用long double类型的浮点数也是用字符串表示，编码为embstr或raw。\n- 如果字符串对象保存的是一个字符串值且长度大于32B，则使用一个简单动态字符串来保存，并将encoding属性设置为raw。\n- 如果字符串对象保存的是一个字符串值且长度小于等于32B，则使用embstr编码方式保存这个字符串值。\n\n**编码转换**\n \n- int编码和embstr编码在满足条件情况下(如APPEND操作增加长度)，会被转换为raw编码\n- Redis没有为embstr编码的字符串对象编写任何相应的修改程序，实际embstr是只读的，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码。\n\n###列表对象\n列表对象的编码可以是`ziplist`或`linkedlist`\n当列表对象同时满足以下两个条件时，列表对象使用`ziplist`编码\n\n- 列表对象保存的所有字符串元素的长度都小于64B(list-max-ziplist-value)\n- 列表对象保存的元素数量小于512个(list-max-ziplist-entries)\n\n当上述条件有一个不满足时，则采用双端链表编码方式，linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象在哈希对象、集合对象和有序集合对象中都会出现，字符串对象是Redis五种类型的对象中唯一会被其他四种类型对象嵌套的对象。\n\n###哈希对象\n哈希对象的编码可以是`ziplist`或`hashtable`\n当哈希对象同时满足以下两个条件时，哈希对象使用`ziplist`编码\n\n- 哈希对象保存的所有字符串元素的长度都小于64B(`hash-max-ziplist-value`)\n- 哈希对象保存的元素数量小于512个(`hash-max-ziplist-entries`)\n\n使用压缩列表保存的哈希对象总是将同一键值对的两个节点紧挨在一起，键的节点在前，值的节点在后；新加入的键值对总是从列表尾部插入。\n\n当条件不满足的时候，采用`hashtable`编码方式，哈希对象中的每个键值对都使用一个字典键值对来保存，其中字典中的键和值分别都是一个字符串对象。\n\n###集合对象\n集合对象的编码可以是`intset`或`hashtable`\n\n- `intset`编码的集合对象使用整数集合作为底层实现，所有元素保存在这个整数集合中\n- `hashtable`编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象 包含一个集合元素，而字典的值则全部为NULL。\n\n使用`intset`编码的条件：\n\n- 集合对象保存的所有元素都是整数值\n- 集合对象保存的元素数量不超过512个(`set-max-inset-entries`)\n\n###有序集合对象\n有序集合对象编码可以是`ziplist`或`skiplist`\n\n- `ziplist`编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨的压缩列表节点保存，第一个节点保存元素的成员，第二个节点保存元素的分值。\n- `skiplist`编码的有序集合对象使用`zset`的结构作为底层实现，定义如下\n\n```C\ntypdef struct zset {\n    zskiplist *zsl;\n    dict       *dict;\n} zset;\n```\n- zset结构中的zsl跳跃表按照分值从小到大保存了所有集合元素\n- zset结构中的dict字典为有序集合创建一个从成员到分值的映射，键是集合元素的成员、值是元素的分值。\n- 有序集合中每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型。\n- 跳跃表和字典数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用两种数据结构不会造成任何重复成员和分值。\n\n当有序集合对象同时满足以下条件时使用`ziplist`编码：\n\n- 有序集合保存的元素数量小于128个(zset-max-ziplist-entries)\n- 有序集合保存的所有元素成员的长度都小于64B(zset-max-ziplist-value)\n\n###类型检查、命令多态、内存回收、对象共享和对象空转时长\n\n**类型检查**\nRedis中命令分为通用命令(任何类型的键均可执行)和专用命令，通用命令包括：`DEL`、`EXPIRE`、`TYPE` 、`OBJECT`\n某些类型专有的命令，在执行命令之前会检测键对应的类型是否合法，非法则报错，通过redisObject中的type属性来实现。\n\n**多态命令**            \nRedis除了根据值得对象类型判断键是否能够执行命令外，还会根据值对象的编码方式，选择正确的命令实现代码来执行。\n\n**内存回收**\nRedis对象系统中构建一个基于引用计数的内存回收机制。对象的整个生命周期分为：创建对象、操作对象、释放对象三个阶段。\n\n```C\nrobj *s = createStringObject(...);\ndescrRefCount(s);\n```\n\n**对象共享**\n对象的引用计数还带有对象共享的作用，在Redis中让多个键共享同一个值对象需要执行下面步骤：\n\n- 将数据库键的值指针指向一个现有的值对象\n- 将被共享的值对象引用计数加一\n\nRedis在初始化的时候会创建一个从0~9999所有整数值，当服务器用到这些字符串的时候，将会直接共享这些对象。`OBJECT REFCOUNT`命令查询引用计数数量。\n\n**对象的空转时长**\n\n- redisObject还有一个`lru`属性记录该对象最后一次被命令程序访问的时间。\n- `OBJECT IDLETIME`命令可以打印出给定键的空转时长(当前时间 - `lru`)，该命令本身不会更新lru属性。\n- 当服务器开启maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或allkeys-lru，那么当服务器内存超过maxmemory值，空转时间较长的会优先回收。"}