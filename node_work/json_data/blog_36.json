{"text":"**意图**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。\n\n**别名**：依赖(Dependents)，发布-订阅(Publish -Subscribe)\n\n**动机**\n将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。\n\n观察者模式中的关键对象是目标( subject)和观察者( observer)。一个目标可以有任意数目的依赖它的观察者。一旦目标的状态发生改变 , 所有的观察者都得到通知。作为对这个通知的响应，每个观察者都将查询目标以使其状态与目标的状态同步。\n这种交互也称为发布－订阅，目标是通知的发布者。它发出通知时并不需知道谁是它的观察者。可以有任意数目的观察者订阅并接收通知。\n\n**适用性**\n\n- 当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。\n- 当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。\n- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。\n\n**结构**\n![enter image description here][1]\n\n**参与者**\n\n- Subject(目标)\n  - 目标知道它的观察者。可以有任意多个观察者观察同一个目标。\n  -  提供注册和删除观察者对象的接口。\n- Observer(观察者)\n  - 为那些在目标发生改变时需获得通知的对象定义一个更新接口。\n- ConcreteSubject(具体目标)\n  - 将有关状态存入各 ConcreteObserver对象。\n  -  当它的状态发生改变时 , 向它的各个观察者发出通知。\n- ConcreteObserver(具体观察者)\n  -  维护一个指向ConcreteSubject对象的引用。\n  - 存储有关状态，这些状态应与目标的状态保持一致。\n  -  实现Observer的更新接口以使自身状态与目标的状态保持一致。\n\n**协作**\n\n-  当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。\n- 在得到一个具体目标的改变通知后 , ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。\n\n**效果**\nObserver模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者 , 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。\n\n- 目标和观察者间的抽象耦合，一个目标所知道的仅仅是它有一系列观察者 , 每个都符合抽象的 Observer类的简单接口。\n- 支持广播通信，不像通常的请求 , 目标发送的通知不需指定它的接收者\n- 意外的更新，因为一个观察者并不知道其它观察者的存在 , 它可能对改变目标的最终代价一无所知\n\n**实现**\n\n- 观察多个目标，一个观察者依赖于多个目标。必须扩展 Update接口以使观察者知道是哪一个目标送来的通知。\n- 创建目标到其观察者之间的映射，一个目标对象跟踪它应通知的观察者的最简单的方法是显式地在目标中保存对它们的引用。然而 , 当目标很多而观察者较少时 , 这样存储可能代价太高。用一个关联查找机制 (例如一个hash表)来维护目标到观察者的映射。这样一个没有观察者的目标就不产生存储开销。\n- 谁触发更新，目标和它的观察者依赖于通知机制来保持一致。\n  - 由目标对象的状态设定操作在改变目标对象的状态后自动调用Notify\n  - 让客户负责在适当的时候调用Notify\n- 对已删除目标的悬挂引用，删除一个目标时应注意不要在其观察者中遗留对该目标的悬挂引用\n- 在发出通知前确保目标的状态自身是一致的，观察者在更新其状态的过程中需要查询目标的当前状态\n- 避免特定于观察者的更新协议—推/拉模型\n  - 目标向观察者发送关于改变的详细信息 , 而不管它们需要与否。称之为**推模型 (push model)**。推模型假定目标知道一些观察者的需要的信息。推模型可能使得观察者相对难以复用，因为目标对观察者的假定可能并不总是正确的。\n  - 目标除最小通知外什么也不送出 ,而在此之后由观察者显式地向目标询问细节，称之为**拉模型(pull model)**。拉模型强调的是目标不知道它的观察者。拉模型可能效率较差 , 因为观察者对象需在没有目标对象帮助的情况下确定什么改变了。\n- 显式地指定感兴趣的改变，可以扩展目标的注册接口 ,让各观察者注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时 , 目标仅通知那些已注册为对该事件感兴趣的观察者。\n- 封装复杂的更新语义 当目标和观察者间的依赖关系特别复杂时 , 可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器(ChangeManager)。它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。\n- 结合目标类和观察者类，允许你定义一个既是一个目标又是一个观察者的对象，而不需要多重继承。\n\n**扩展**\nDelegation Event Model (DEM) (Java AWT/Swing/Servlet)\n\n- Event，对应`java.util.EventObject`，event对象从Source对象传播到Listener对象(通过Listener上的方法调用)。\n- Listener，实现了`java.util.EventListener`接口，EventListener定义一个或多个用于source调用的方法并对应不同事件类型。\n- Source，是触发事件的对象。其定义了set<EventType>Listener用于单一传播和add<EventType>Listener用于广播这些事件。\n\n###JDK中实例\n- `java.util.Observer`(观察者)、`java.util.Obervable`(目标)\n- All implementations of `java.util.EventListener`(practically all over Swing thus)\n- `javax.servlet.http.HttpSessionBindingListener`\n- `javax.servlet.http.HttpSessionAttributeListener`\n- `javax.faces.event.PhaseListener`\n\n  [1]: http://img.itc.cn/photo/j3if00GkDEv"}